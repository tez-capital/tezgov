import{E as f,G as O,H as x,O as p,J as I,P as o,K as g,p as S}from"./main-02e039e1.js";import{S as T}from"./SessionBase-46796db9.js";import{connect_beacon_wallet as P,disconnect_beacon_wallet as G}from"./beacon-ce7d3b99.js";import{S as _}from"./DAppClient-5fff09c6.js";import"./taquito.es6-c85b4f48.js";class y extends T{constructor(t,s,n,a,e){super(t,n,a,e),this.wallet=s}get AccountType(){return f.Beacon}get Icon(){return new O("/assets/svg/beacon-wallet-icon.svg",x.raw)}static async create(t,s){const n=I[t];if(!n)throw new Error("Invalid network specification!");const{account:a,tezos:e,forger:c,managerKey:u,wallet:i}=await P(n.id??t,{...s,rpc:(s==null?void 0:s.rpc)??n.rpc});return new y(a??"",i,e,c,{networkId:t,managerKey:u})}static async create_from_cache(){}logout(){G()}async switch_wallet(){return y.create(this.NetworkId,{rpc:this.Tezos.rpc.getRpcUrl(),useCached:!1})}async vote(t,s){if(s){const e=await this.forge_ballot_op(t),c=async()=>{const u=this.Tezos.wallet.context,i=await this.wallet.client.requestSignPayload({signingType:_.OPERATION,payload:"03"+e});let r=o.SIG;switch(i.signature.slice(0,5)){case o.EDSIG:r=o.EDSIG;break;case o.SPSIG:r=o.SPSIG;break;case o.P2SIG:r=o.P2SIG;break}const l=[...g(i.signature,S[r])].map(w=>w.toString(16).padStart(2,"0")).join(""),h=await this.Tezos.rpc.injectOperation(e.concat(l));return u.operationFactory.createOperation(h)};return new p(c,"Vote",{account:this.Account,ballot:t})}const n=await this.forge_ballot(t),a=async()=>{const e=this.Tezos.wallet.context,c=await this.wallet.sendOperations([n]);return e.operationFactory.createOperation(c)};return new p(a,"Vote",{account:this.Account,ballot:t})}async propose(t,s){if(s){const e=await this.forge_proposals_op(t),c=async()=>{const u=this.Tezos.wallet.context,i=await this.wallet.client.requestSignPayload({signingType:_.OPERATION,payload:"03".concat(e)});let r=o.SIG;switch(i.signature.slice(0,5)){case o.EDSIG:r=o.EDSIG;break;case o.SPSIG:r=o.SPSIG;break;case o.P2SIG:r=o.P2SIG;break}const l=[...g(i.signature,S[r])].map(w=>w.toString(16).padStart(2,"0")).join(""),h=await this.Tezos.rpc.injectOperation(e.concat(l));return u.operationFactory.createOperation(h)};return new p(c,"Propose",{account:this.Account,proposals:t})}const n=await this.forge_proposals(t),a=async()=>{const e=this.Tezos.wallet.context,c=await this.wallet.sendOperations([n]);return e.operationFactory.createOperation(c)};return new p(a,"Propose",{account:this.Account,proposals:t})}async set_deposits_limit(t){const s=await this.forge_set_deposit_op(t),n=async()=>{const a=this.Tezos.wallet.context,e=await this.wallet.sendOperations([s]);return a.operationFactory.createOperation(e)};return new p(n,"Set Deposit",{account:this.Account,limit:t.toString()})}async update_consensus_key(t){const s=await this.forge_update_consensus_key_op(t),n=async()=>{const a=this.Tezos.wallet.context,e=await this.wallet.sendOperations([s]);return a.operationFactory.createOperation(e)};return new p(n,"Set Deposit",{account:this.Account,"Consensus Key":t})}async restore_consensus_key(){const t=await this.Tezos.signer.publicKey(),s=await this.forge_update_consensus_key_op(t),n=async()=>{const a=this.Tezos.wallet.context,e=await this.Tezos.signer.sign(s,new Uint8Array([3])),c=await this.Tezos.rpc.injectOperation(e.sbytes);return a.operationFactory.createOperation(c)};return new p(n,"Restore consensus key",{account:this.Account,"Consensus Key":t})}}export{y as BeaconSession};
