function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["assets/taquito-D6qPcyQT.js","assets/taquito.es6-BcXy095G.js","assets/main-BCV0SOQi.js","assets/main-CJpwEAG2.css"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
import{p as o,W as S,V as f,X as O,i as _,Y as k,d as A,Z as K,$ as U,a0 as b,a1 as m,a2 as I,a3 as R,K as z,a4 as F,b as T,c as B,a5 as P,T as y,_ as V,E as D,G as N,H,O as u,U as $,J as j}from"./main-BCV0SOQi.js";import{S as q}from"./SessionBase-C_SxFsBu.js";import{H as C,a as E,S as w}from"./taquito.es6-BcXy095G.js";import"./WalletConnectCommunicationClient-DQML_FDf.js";function d(h,t,e,s){function n(i){return i instanceof e?i:new e(function(r){r(i)})}return new(e||(e=Promise))(function(i,r){function a(p){try{l(s.next(p))}catch(g){r(g)}}function c(p){try{l(s.throw(p))}catch(g){r(g)}}function l(p){p.done?i(p.value):n(p.value).then(a,c)}l((s=s.apply(h,t||[])).next())})}class L extends P{constructor(t,e){super(),this.message=t,this.cause=e,this.name="OperationNotAuthorized"}}class W extends y{constructor(t,e,s){super(),this.cause=t,this.bytes=e,this.watermark=s,this.name="BadSigningData",this.message=s?"Invalid signing data with watermark":`Invalid signing data: "${e}"`}}class G extends y{constructor(t,e,s){super(),this.requestedPk=t,this.requestedPkh=e,this.initializedPkh=s,this.name="PublicKeyVerificationFailedError",this.message=`Requested pk "${t}" has pkh "${e}" deesn't match initialized pkh "${s}."`}}class M extends y{constructor(t,e){super(),this.bytes=t,this.signature=e,this.name="SignatureVerificationFailedError",this.name="SignatureVerificationFailedError",this.message="Invalid signature of bytes failed verification agaisnt public key."}}const v={ed:{pk:o.edpk,sk:o.edsk,pkh:o.tz1,sig:o.edsig},p2:{pk:o.p2pk,sk:o.p2sk,pkh:o.tz3,sig:o.p2sig},sp:{pk:o.sppk,sk:o.spsk,pkh:o.tz2,sig:o.spsig}};class X{constructor(t,e,s={},n=new C){this.pkh=t,this.rootUrl=e,this.options=s,this.http=n;const i=S(this.pkh);if(i!==f.VALID)throw new O(this.pkh,_(i))}publicKeyHash(){return d(this,void 0,void 0,function*(){return this.pkh})}createURL(t){let e=this.rootUrl;for(;e.endsWith("/");)e=e.slice(0,-1);return`${e}${t}`}publicKey(){return d(this,void 0,void 0,function*(){try{const{public_key:t}=yield this.http.createRequest({url:this.createURL(`/keys/${this.pkh}`),method:"GET",headers:this.options.headers});return t}catch(t){throw t instanceof E&&t.status===w.NOT_FOUND?new k(this.pkh,t):t}})}secretKey(){return d(this,void 0,void 0,function*(){throw new A("Secret key cannot be exposed")})}sign(t,e){return d(this,void 0,void 0,function*(){try{let s=K(t);typeof e<"u"&&(s=U(e,s));const n=b(m(s)),{signature:i}=yield this.http.createRequest({url:this.createURL(`/keys/${this.pkh}`),method:"POST",headers:this.options.headers},n),r=i.startsWith("sig")?i.substring(0,3):i.substring(0,5);if(!I(r))throw new R(i,_(f.NO_PREFIX_MATCHED)+" from a remote signer.");const a=z(i,o[r]),c=yield this.publicKey();if(yield this.verifyPublicKey(c),!F(n,c,i))throw new M(n,i);return{bytes:t,sig:T(a,o.sig),prefixSig:i,sbytes:t+b(m(a))}}catch(s){if(s instanceof E){if(s.status===w.NOT_FOUND)throw new k(this.pkh,s);if(s.status===w.FORBIDDEN)throw new L("Signing Operation not authorized",s);if(s.status===w.BAD_REQUEST)throw new W(s,t,e)}throw s}})}verifyPublicKey(t){return d(this,void 0,void 0,function*(){const e=t.substring(0,2),s=z(t,v[e].pk),n=T(B.hash(s,20),v[e].pkh);if(n!==this.pkh)throw new G(t,n,this.pkh)})}}const J=async(h,t,e)=>{const{create_toolkit:s}=await V(()=>import("./taquito-D6qPcyQT.js"),__vite__mapDeps([0,1,2,3])),{tezos:n,forger:i}=await s(e.rpc),r=new X(h,t);n.setSignerProvider(r);const a=h,c=a?await n.rpc.getManagerKey(a):void 0;return{account:a,tezos:n,forger:i,managerKey:c==null?void 0:c.toString()}},{request_ledger_setup:Q}=$();class x extends q{constructor(t,e,s,n,i){super(t,s,n,i),this.url=e}get AccountType(){return D.Remote}get Icon(){return new N("cloud",H.icon)}get IsAccountSwitchSupported(){return!1}static async create(t,e,s,n){const i=j[s];if(!i)throw new Error("Invalid network specification!");const{tezos:r,forger:a,managerKey:c}=await J(t,e,{...n,rpc:(n==null?void 0:n.rpc)??i.rpc});return new x(t,e,r,a,{networkId:s,managerKey:c})}static async create_from_cache(){}logout(){}async switch_wallet(){const t=await Q({networkId:this.NetworkId,rpc:this.Tezos.rpc.getRpcUrl()});if(!t)throw new Error("Aborted.");return t}async vote(t){const e=await this.forge_ballot_op(t),s=async()=>{const n=this.Tezos.wallet.context,i=await this.Tezos.signer.sign(e,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(i.sbytes);return n.operationFactory.createOperation(r)};return new u(s,"Vote",{account:this.Account,ballot:t})}async propose(t){const e=await this.forge_proposals_op(t),s=async()=>{const n=this.Tezos.wallet.context,i=await this.Tezos.signer.sign(e,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(i.sbytes);return n.operationFactory.createOperation(r)};return new u(s,"Propose",{account:this.Account,proposals:t})}async set_deposits_limit(t){const e=await this.forge_set_deposit_op(t),s=async()=>{const n=this.Tezos.wallet.context,i=await this.Tezos.signer.sign(e,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(i.sbytes);return n.operationFactory.createOperation(r)};return new u(s,"Propose",{account:this.Account,limit:t.toString()})}async update_consensus_key(t){const e=await this.forge_update_consensus_key_op(t),s=async()=>{const n=this.Tezos.wallet.context,i=await this.Tezos.signer.sign(e,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(i.sbytes);return n.operationFactory.createOperation(r)};return new u(s,"Propose",{account:this.Account,"Consensus Key":t})}async restore_consensus_key(){const t=await this.Tezos.signer.publicKey(),e=await this.forge_update_consensus_key_op(t),s=async()=>{const n=this.Tezos.wallet.context,i=await this.Tezos.signer.sign(e,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(i.sbytes);return n.operationFactory.createOperation(r)};return new u(s,"Restore consensus key",{account:this.Account,"Consensus Key":t})}async finalize_unstake(){const t=await this.forge_finalize_unstake(),e=async()=>{const s=this.Tezos.wallet.context,n=await this.Tezos.signer.sign(t,new Uint8Array([3])),i=await this.Tezos.rpc.injectOperation(n.sbytes);return s.operationFactory.createOperation(i)};return new u(e,"Finalize Unstake",{account:this.Account})}}export{x as RemoteSession};
