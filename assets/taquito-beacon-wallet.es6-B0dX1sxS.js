var re=Object.defineProperty;var oe=(w,s,e)=>s in w?re(w,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):w[s]=e;var d=(w,s,e)=>(oe(w,typeof s!="symbol"?s+"":s,e),e);import{a as C,w as b,b as P,c as ce,t as ee,g as $,d as x,e as le,f as he,B as u,P as N,h as te,i as S,j as V,k as W,l as U,L,m as se,n as M,o as de,p as ne,O as v,N as A,q as ie,W as G,r as j,s as pe,u as Q,C as ue,v as g,x as J,y as we,z as ge,A as fe,D as ye,F as Ae,S as k,G as q,H as me,I as Pe,J as Ee,K as Te,M as ve,Q as X,R as Ie,U as Y,V as Ce,X as Re,Y as ke,Z as Ne,_ as Z}from"./WalletConnectCommunicationClient-Cz6Pe2wn.js";import{c as Oe,ai as Se,M as Le,a5 as ae,Z as _e,$ as Me,a0 as be,a1 as qe,aj as De}from"./main-DoEQfgBz.js";import{d as xe,e as We,f as Ue,g as Be}from"./taquito.es6-Dsmsy2d-.js";class Fe{track(s,e,t,i){}}class Ke{constructor(s){d(this,"name");d(this,"iconUrl");d(this,"appUrl");d(this,"_beaconId",new C);d(this,"storage");d(this,"analytics");d(this,"_keyPair",new C);if(!s.name)throw new Error("Name not set");if(!s.storage)throw new Error("Storage not set");this.name=s.name,this.iconUrl=s.iconUrl,this.appUrl=s.appUrl??b.location.origin,this.storage=s.storage,this.analytics=s.analytics??new Fe,b.beaconCreatedClientInstance?console.error("[BEACON] It looks like you created multiple Beacon SDK Client instances. This can lead to problems. Only create one instance and re-use it everywhere."):b.beaconCreatedClientInstance=!0,this.initSDK().catch(console.error)}get beaconId(){return this._beaconId.promise}get keyPair(){return this._keyPair.promise}async destroy(){await this.removeBeaconEntriesFromStorage(),b.beaconCreatedClientInstance=!1}async initSDK(){return this.storage.set(P.BEACON_SDK_VERSION,ce).catch(console.error),this.loadOrCreateBeaconSecret().catch(console.error),this.keyPair.then(s=>{this._beaconId.resolve(ee(s.publicKey))})}async removeBeaconEntriesFromStorage(){const s=Object.values(P);await Promise.all(s.map(e=>this.storage.delete(e)))}async loadOrCreateBeaconSecret(){const s=await this.storage.get(P.BEACON_SDK_SECRET_SEED);if(s&&typeof s=="string")this._keyPair.resolve(await $(s));else{const e=await x();await this.storage.set(P.BEACON_SDK_SECRET_SEED,e),this._keyPair.resolve(await $(e))}}}const z=async(w,s)=>{const e=[w,s.type];s.name&&e.push(`name:${s.name}`),s.rpcUrl&&e.push(`rpc:${s.rpcUrl}`);const t=Buffer.from(Oe.hash(le(e.join("-")),10));return he.encode(t)};class He{static async hasPermission(s,e,t){switch(s.type){case u.PermissionRequest:case u.BroadcastRequest:return!0;case u.OperationRequest:{const i=await z(s.sourceAddress,s.network),n=await e(i);return n?n.scopes.includes(N.OPERATION_REQUEST):!1}case u.SignPayloadRequest:{const n=(await t()).filter(a=>a.address===s.sourceAddress);return n.length===0?!1:n.some(a=>a.scopes.includes(N.SIGN))}default:throw new Error("Message not handled")}}}class ze{constructor(s){d(this,"storageManager");this.storageManager=new te(s,P.ACCOUNTS)}async getAccounts(){return await this.storageManager.getAll()??[]}async getAccount(s){return this.storageManager.getOne(e=>e.accountIdentifier===s)}async addAccount(s){return this.storageManager.addOne(s,e=>e.accountIdentifier===s.accountIdentifier)}async updateAccount(s,e){const t=await this.getAccount(s);if(!t)return;const i={...t,...e};return await this.storageManager.addOne(i,n=>n.accountIdentifier===s,!0),i}async removeAccount(s){return this.storageManager.remove(e=>e.accountIdentifier===s)}async removeAccounts(s){return this.storageManager.remove(e=>s.includes(e.accountIdentifier))}async removeAllAccounts(){return this.storageManager.removeAll()}async hasPermission(s){return He.hasPermission(s,this.getAccount.bind(this),this.getAccounts.bind(this))}}const $e=new L("Client");class Ve extends Ke{constructor(e){super(e);d(this,"accountManager");d(this,"handleResponse");d(this,"rateLimit",2);d(this,"rateLimitWindowInSeconds",5);d(this,"requestCounter",[]);d(this,"matrixNodes");d(this,"_transport",new C);this.accountManager=new ze(e.storage),this.matrixNodes=e.matrixNodes??{},this.handleResponse=(t,i)=>{throw new Error(`not overwritten${JSON.stringify(t)} - ${JSON.stringify(i)}`)}}get transport(){return this._transport.promise}get connectionStatus(){var e;return((e=this._transport.promiseResult)==null?void 0:e.connectionStatus)??S.NOT_CONNECTED}get ready(){return this.transport.then(()=>{})}async getAccounts(){return this.accountManager.getAccounts()}async getAccount(e){return this.accountManager.getAccount(e)}async removeAccount(e){return this.accountManager.removeAccount(e)}async removeAllAccounts(){return this.accountManager.removeAllAccounts()}async addRequestAndCheckIfRateLimited(){const e=new Date().getTime();return this.requestCounter=this.requestCounter.filter(t=>t+this.rateLimitWindowInSeconds*1e3>e),this.requestCounter.push(e),this.requestCounter.length>this.rateLimit}async init(e){return this._transport.status===V.RESOLVED?(await this.transport).type:(await this.setTransport(e),e.type)}async getOwnAppMetadata(){return{senderId:await W(await this.beaconId),name:this.name,icon:this.iconUrl}}async getPeers(){return(await this.transport).getPeers()}async addPeer(e){return(await this.transport).addPeer(e)}async destroy(){this._transport.status===V.RESOLVED&&await(await this.transport).disconnect(),await super.destroy()}async setTransport(e){e?this._transport.isSettled()?this._transport=C.resolve(e):this._transport.resolve(e):this._transport.isSettled()&&(this._transport=new C)}async addListener(e){e.addListener(async(t,i)=>{if(typeof t=="string"){const n=await new U().deserialize(t);this.handleResponse(n,i)}}).catch(t=>$e.error("addListener",t))}async sendDisconnectToPeer(e,t){const i={id:await x(),version:e.version,senderId:await W(await this.beaconId),type:u.Disconnect},n=await new U().serialize(i);await(t??await this.transport).send(n,e)}}class Ge{constructor(s){d(this,"storageManager");this.storageManager=new te(s,P.APP_METADATA_LIST)}async getAppMetadataList(){return await this.storageManager.getAll()??[]}async getAppMetadata(s){return this.storageManager.getOne(e=>e.senderId===s)}async addAppMetadata(s){return this.storageManager.addOne(s,e=>e.senderId===s.senderId)}async removeAppMetadata(s){return this.storageManager.remove(e=>e.senderId===s)}async removeAppMetadatas(s){return this.storageManager.remove(e=>s.includes(e.senderId))}async removeAllAppMetadata(){return this.storageManager.removeAll()}}const B=new L("P2PTransport");class je extends se{constructor(e,t,i,n,a,r,l){super(e,new de(e,t,1,i,n,r,l),new ne(i,a));d(this,"type",M.P2P)}static async isAvailable(){return Promise.resolve(!0)}async connect(){if(this._isConnected!==S.NOT_CONNECTED)return;B.log("connect"),this._isConnected=S.CONNECTING,await this.client.start();const e=await this.getPeers();if(e.length>0){B.log("connect",`connecting to ${e.length} peers`);const t=e.map(async i=>this.listen(i.publicKey));Promise.all(t).catch(i=>B.error("connect",i))}return await this.startOpenChannelListener(),super.connect()}async disconnect(){return await this.client.stop(),super.disconnect()}async startOpenChannelListener(){}async getPairingRequestInfo(){return this.client.getPairingRequestInfo()}async listen(e){await this.client.listenForEncryptedMessage(e,t=>{const i={origin:v.P2P,id:e};this.notifyListeners(t,i).catch(n=>{throw n})}).catch(t=>{throw t})}}class Qe{constructor(s){d(this,"rpcUrls");this.rpcUrls=s}async getLinkForNetwork(s){return this.rpcUrls[s.type]}}class Je extends Qe{constructor(e={[A.MAINNET]:"https://tzkt.io",[A.GHOSTNET]:"https://ghostnet.tzkt.io",[A.WEEKLYNET]:"https://weeklynet.tzkt.io",[A.DAILYNET]:"https://dailynet.tzkt.io",[A.DELPHINET]:"https://delphinet.tzkt.io",[A.EDONET]:"https://edonet.tzkt.io",[A.FLORENCENET]:"https://florencenet.tzkt.io",[A.GRANADANET]:"https://granadanet.tzkt.io",[A.HANGZHOUNET]:"https://hangzhounet.tzkt.io",[A.ITHACANET]:"https://ithacanet.tzkt.io",[A.JAKARTANET]:"https://jakartanet.tzkt.io",[A.KATHMANDUNET]:"https://kathmandunet.tzkt.io",[A.LIMANET]:"https://limanet.tzkt.io",[A.MUMBAINET]:"https://mumbainet.tzkt.io",[A.NAIROBINET]:"https://nairobinet.tzkt.io",[A.OXFORDNET]:"https://oxfordnet.tzkt.io",[A.CUSTOM]:"https://oxfordnet.tzkt.io"}){super(e);d(this,"rpcUrls");this.rpcUrls=e}async getAddressLink(e,t){return`${await this.getLinkForNetwork(t)}/${e}`}async getTransactionLink(e,t){return`${await this.getLinkForNetwork(t)}/${e}`}}const F=new L("DappPostMessageTransport");class Xe extends ie{constructor(s,e,t){super(s,e,t,P.TRANSPORT_POSTMESSAGE_PEERS_DAPP)}async startOpenChannelListener(){return this.client.listenForChannelOpening(async s=>{F.log("connect","received PostMessagePairingResponse",s),await this.addPeer(s),this._isConnected=S.CONNECTED,this.newPeerListener&&(this.newPeerListener(s),this.newPeerListener=void 0)})}async listenForNewPeer(s){F.log("listenForNewPeer"),this.newPeerListener=s}async stopListeningForNewPeers(){F.log("stopListeningForNewPeers"),this.newPeerListener=void 0}}const K=new L("DappP2PTransport");class Ye extends je{constructor(s,e,t,i,n,a){super(s,e,t,i,P.TRANSPORT_P2P_PEERS_DAPP,n,a)}async startOpenChannelListener(){return this.client.listenForChannelOpening(async s=>{K.log("listenForNewPeer","new publicKey",s.publicKey),await this.addPeer(s),this._isConnected=S.CONNECTED,this.newPeerListener&&(this.newPeerListener(s),this.newPeerListener=void 0)})}async listenForNewPeer(s){K.log("listenForNewPeer"),this.newPeerListener=s}async stopListeningForNewPeers(){K.log("stopListeningForNewPeers"),this.newPeerListener=void 0}}class D extends se{constructor(e,t,i,n,a){super(e,G.getInstance(a),new ne(i,n));d(this,"wcOptions");this.wcOptions=a}static async isAvailable(){return Promise.resolve(!0)}async connect(){if(this._isConnected!==S.NOT_CONNECTED)return;this._isConnected=S.CONNECTING,await this.client.init();const e=await this.getPeers();return e.length>0&&e.map(async t=>this.listen(t.publicKey)),await this.startOpenChannelListener(),super.connect()}async hasPairings(){var e,t;return await this.client.storage.hasPairings()?!0:!!((t=(e=this.client.signClient)==null?void 0:e.pairing.getAll())!=null&&t.length)}async hasSessions(){var e,t;return await this.client.storage.hasSessions()?!0:!!((t=(e=this.client.signClient)==null?void 0:e.session.getAll())!=null&&t.length)}async closeActiveSession(e){!await this.hasPairings()||!await this.hasPairings()?await this.disconnect():await this.client.closeActiveSession(e.address)}async getPeers(){const t=G.getInstance(this.wcOptions).currentSession();return t?[{senderId:t.peer.publicKey,extensionId:t.peer.metadata.name,id:t.peer.publicKey,type:"walletconnect-pairing-response",name:"peer",publicKey:t.peer.publicKey,version:"first"}]:[]}async disconnect(){return await this.client.close(),super.disconnect()}async startOpenChannelListener(){}getPairingRequestInfo(){return this.client.getPairingRequestInfo()}async listen(e){await this.client.listenForEncryptedMessage(e,t=>{const i={origin:v.WALLETCONNECT,id:e};this.notifyListeners(t,i).catch(n=>{throw n})}).catch(t=>{throw t})}}const Ze=new L("DappWalletConnectTransport");class et extends D{constructor(s,e,t,i){super(s,e,t,P.TRANSPORT_WALLETCONNECT_PEERS_DAPP,i),this.client.listenForChannelOpening(async n=>{await this.addPeer(n),this._isConnected=S.CONNECTED,this.newPeerListener&&(this.newPeerListener(n),this.newPeerListener=void 0)})}async listenForNewPeer(s){this.newPeerListener=s}async stopListeningForNewPeers(){Ze.log("stopListeningForNewPeers"),this.newPeerListener=void 0}}const c=new L("DAppClient");class tt extends Ve{constructor(e){var t,i;super({storage:e&&e.storage?e.storage:new pe,...e});d(this,"description");d(this,"blockExplorer");d(this,"network");d(this,"events",new j);d(this,"postMessageTransport");d(this,"p2pTransport");d(this,"walletConnectTransport");d(this,"wcProjectId");d(this,"wcRelayUrl");d(this,"isGetActiveAccountHandled",!1);d(this,"openRequests",new Map);d(this,"_activeAccount",new C);d(this,"_activePeer",new C);d(this,"_initPromise");d(this,"isInitPending",!1);d(this,"activeAccountLoaded");d(this,"appMetadataManager");d(this,"disclaimerText");d(this,"errorMessages");d(this,"featuredWallets");d(this,"blockchains",new Map);this.description=e.description,this.wcProjectId=((t=e.walletConnectOptions)==null?void 0:t.projectId)||"24469fd0a06df227b6e5f7dc7de0ff4f",this.wcRelayUrl=(i=e.walletConnectOptions)==null?void 0:i.relayUrl,this.featuredWallets=e.featuredWallets,this.events=new j(e.eventHandlers,e.disableDefaultEvents??!1),this.blockExplorer=e.blockExplorer??new Je,this.network=e.network??{type:e.preferredNetwork??A.MAINNET},Q(e.colorMode??ue.LIGHT),this.disclaimerText=e.disclaimerText,this.errorMessages=e.errorMessages??{},this.appMetadataManager=new Ge(this.storage),this.storage.subscribeToStorageChanged(async n=>{if(n.eventType==="storageCleared")this.setActiveAccount(void 0);else if(n.eventType==="entryModified"&&n.key===this.storage.getPrefixedKey(P.ACTIVE_ACCOUNT)){const a=n.newValue;if(!a||a==="undefined")this.setActiveAccount(void 0);else{const r=await this.getAccount(a);this.setActiveAccount(r)}}}),this.activeAccountLoaded=this.storage.get(P.ACTIVE_ACCOUNT).then(async n=>{if(n){const a=await this.accountManager.getAccount(n);return await this.setActiveAccount(a),a}else{await this.setActiveAccount(void 0);return}}).catch(async n=>{await this.setActiveAccount(void 0),console.error(n)}),this.handleResponse=async(n,a)=>{var l,o,p,f,E,T;const r=this.openRequests.get(n.id);if(c.log("### openRequest ###",r),c.log("handleResponse","Received message",n,a),c.log("### message ###",JSON.stringify(n)),c.log("### connectionInfo ###",a),n.version==="3"){const h=n;if(r&&((l=h.message)==null?void 0:l.type)===u.Acknowledge)this.analytics.track("event","DAppClient","Acknowledge received from Wallet"),c.log("handleResponse",`acknowledge message received for ${n.id}`),c.timeLog("handleResponse",n.id,"acknowledge"),this.events.emit(g.ACKNOWLEDGE_RECEIVED,{message:h.message,extraInfo:{},walletInfo:await this.getWalletInfo()}).catch(console.error);else if(r){const m=h.message.blockchainData.appMetadata;((o=h.message)==null?void 0:o.type)===u.PermissionResponse&&m&&await this.appMetadataManager.addAppMetadata(m),c.timeLog("handleResponse",h.id,"response"),c.time(!1,h.id),((p=h.message)==null?void 0:p.type)===u.Error?r.reject(h.message):r.resolve({message:n,connectionInfo:a}),this.openRequests.delete(h.id)}else if(((f=h.message)==null?void 0:f.type)===u.Disconnect){this.analytics.track("event","DAppClient","Disconnect received from Wallet");const m=a.origin===v.P2P?this.p2pTransport:a.origin===v.WALLETCONNECT?this.walletConnectTransport:this.postMessageTransport??await this.transport;if(m){const R=(await m.getPeers()).find(_=>_.senderId===n.senderId);R&&await m.removePeer(R),await this.removeAccountsForPeerIds([n.senderId]),await this.events.emit(g.CHANNEL_CLOSED)}}else((E=h.message)==null?void 0:E.type)===u.ChangeAccountRequest?await this.onNewAccount(h.message,a):c.error("handleResponse","no request found for id ",n.id,n)}else{const h=n;if(r&&h.type===u.Acknowledge)c.log("handleResponse",`acknowledge message received for ${n.id}`),this.analytics.track("event","DAppClient","Acknowledge received from Wallet"),c.timeLog("handleResponse",n.id,"acknowledge"),this.events.emit(g.ACKNOWLEDGE_RECEIVED,{message:h,extraInfo:{},walletInfo:await this.getWalletInfo()}).catch(console.error);else if(r)h.type===u.PermissionResponse&&h.appMetadata&&await this.appMetadataManager.addAppMetadata(h.appMetadata),c.timeLog("handleResponse",h.id,"response"),c.time(!1,h.id),h.type===u.Error||n.errorType?r.reject(h):r.resolve({message:n,connectionInfo:a}),this.openRequests.delete(h.id);else if(h.type===u.Disconnect||((T=n==null?void 0:n.typedMessage)==null?void 0:T.type)===u.Disconnect){this.analytics.track("event","DAppClient","Disconnect received from Wallet");const m=a.origin===v.P2P?this.p2pTransport:a.origin===v.WALLETCONNECT?this.walletConnectTransport:this.postMessageTransport??await this.transport;if(m){const R=(await m.getPeers()).find(_=>_.senderId===n.senderId);R&&await m.removePeer(R),await this.removeAccountsForPeerIds([n.senderId]),await this.events.emit(g.CHANNEL_CLOSED)}}else h.type===u.ChangeAccountRequest?await this.onNewAccount(h,a):c.error("handleResponse","no request found for id ",n.id,n)}},this.activeAccountLoaded.then(n=>{n&&n.origin.type!=="p2p"&&this.init()})}async initInternalTransports(){const e=await this.keyPair;if(this.postMessageTransport||this.p2pTransport||this.walletConnectTransport)return;this.postMessageTransport=new Xe(this.name,e,this.storage),await this.addListener(this.postMessageTransport),this.p2pTransport=new Ye(this.name,e,this.storage,this.matrixNodes,this.iconUrl,this.appUrl),await this.addListener(this.p2pTransport);const t={projectId:this.wcProjectId,relayUrl:this.wcRelayUrl,metadata:{name:this.name,description:this.description??"",url:this.appUrl??"",icons:this.iconUrl?[this.iconUrl]:[]}};this.walletConnectTransport=new et(this.name,e,this.storage,{network:this.network.type,opts:t}),this.initEvents(),await this.addListener(this.walletConnectTransport)}initEvents(){this.walletConnectTransport&&(this.walletConnectTransport.setEventHandler("CLOSE_ALERT",this.hideUI.bind(this,["alert"])),this.walletConnectTransport.setEventHandler("RESET_STATE",this.channelClosedHandler.bind(this)),this.walletConnectTransport.setEventHandler("WC_ACK_NOTIFICATION",this.wcToastHandler.bind(this)))}async wcToastHandler(e){const t=await(async()=>{try{return await this.getWalletInfo()}catch{return{name:"wallet"}}})();await this.events.emit(g.HIDE_UI,["alert"]),e==="pending"?this.events.emit(g.ACKNOWLEDGE_RECEIVED,{message:{},extraInfo:{},walletInfo:t}):this.events.emit(g.PERMISSION_REQUEST_ERROR,{errorResponse:{errorType:J.ABORTED_ERROR},walletInfo:t})}async channelClosedHandler(e){const t=await this.transport;e&&t.type!==e||(await this.events.emit(g.CHANNEL_CLOSED),this.setActiveAccount(void 0),await this.destroy())}async destroy(){await super.destroy()}async init(e){if(this._initPromise)return this._initPromise;try{await this.activeAccountLoaded}catch{}return this._initPromise=new Promise(async t=>{if(e)await this.addListener(e),t(await super.init(e));else if(this._transport.isSettled())await(await this.transport).connect(),t(await super.init(await this.transport));else{const i=await this.getActiveAccount(),n=()=>{this.postMessageTransport&&this.postMessageTransport.stopListeningForNewPeers().catch(console.error),this.p2pTransport&&this.p2pTransport.stopListeningForNewPeers().catch(console.error),this.walletConnectTransport&&this.walletConnectTransport.stopListeningForNewPeers().catch(console.error)};if(await this.initInternalTransports(),!this.postMessageTransport||!this.p2pTransport||!this.walletConnectTransport)return;if(this.postMessageTransport.connect().then().catch(console.error),i&&i.origin){const a=i.origin.type;a===v.EXTENSION?t(await super.init(this.postMessageTransport)):a===v.P2P?t(await super.init(this.p2pTransport)):a===v.WALLETCONNECT&&t(await super.init(this.walletConnectTransport))}else{const a=this.p2pTransport,r=this.postMessageTransport,l=this.walletConnectTransport;r.listenForNewPeer(o=>{c.log("init","postmessage transport peer connected",o),this.analytics.track("event","DAppClient","Extension connected",{peerName:o.name}),this.events.emit(g.PAIR_SUCCESS,o).catch(p=>console.warn(p)),this.setActivePeer(o).catch(console.error),this.setTransport(this.postMessageTransport).catch(console.error),n(),t(M.POST_MESSAGE)}).catch(console.error),a.listenForNewPeer(o=>{c.log("init","p2p transport peer connected",o),this.analytics.track("event","DAppClient","Beacon Wallet connected",{peerName:o.name}),this.events.emit(g.PAIR_SUCCESS,o).catch(p=>console.warn(p)),this.setActivePeer(o).catch(console.error),this.setTransport(this.p2pTransport).catch(console.error),n(),t(M.P2P)}).catch(console.error),l.listenForNewPeer(o=>{c.log("init","walletconnect transport peer connected",o),this.analytics.track("event","DAppClient","WalletConnect Wallet connected",{peerName:o.name}),this.events.emit(g.PAIR_SUCCESS,o).catch(p=>console.warn(p)),this.setActivePeer(o).catch(console.error),this.setTransport(this.walletConnectTransport).catch(console.error),n(),t(M.WALLETCONNECT)}).catch(console.error),ie.getAvailableExtensions().then(async o=>{this.analytics.track("event","DAppClient","Extensions detected",{extensions:o})}).catch(o=>{this._initPromise=void 0,console.error(o)}),this.events.emit(g.PAIR_INIT,{p2pPeerInfo:()=>(a.connect().then().catch(console.error),a.getPairingRequestInfo()),postmessagePeerInfo:()=>r.getPairingRequestInfo(),walletConnectPeerInfo:()=>l.getPairingRequestInfo(),networkType:this.network.type,abortedHandler:async()=>{c.log("init","ABORTED"),await Promise.all([r.disconnect(),l.disconnect()]),this._initPromise=void 0},disclaimerText:this.disclaimerText,analytics:this.analytics,featuredWallets:this.featuredWallets}).catch(o=>console.warn(o))}}}),this._initPromise}async getActiveAccount(){return this._activeAccount.promise}async isInvalidState(e){const t=await this._activeAccount.promise;return t?(t==null?void 0:t.address)!==e.address&&!this.isGetActiveAccountHandled:!1}async setActiveAccount(e){if(e&&this._activeAccount.isSettled()&&await this.isInvalidState(e)){await this.destroy(),await this.setActiveAccount(void 0),await this.events.emit(g.INVALID_ACTIVE_ACCOUNT_STATE);return}if(!e&&this._activeAccount.isResolved()&&await this.getActiveAccount()){const t=await this.transport,i=await this.getActiveAccount();if(!t||!i)return;t instanceof D&&await t.closeActiveSession(i)}if(this._activeAccount.isSettled()?this._activeAccount=C.resolve(e):this._activeAccount.resolve(e),e){const t=e.origin.type;await this.initInternalTransports(),t===v.EXTENSION?await this.setTransport(this.postMessageTransport):t===v.P2P?await this.setTransport(this.p2pTransport):t===v.WALLETCONNECT&&await this.setTransport(this.walletConnectTransport);const i=await this.getPeer(e);await this.setActivePeer(i)}else await this.setActivePeer(void 0),await this.setTransport(void 0);await this.storage.set(P.ACTIVE_ACCOUNT,e?e.accountIdentifier:void 0),await this.events.emit(g.ACTIVE_ACCOUNT_SET,e)}clearActiveAccount(){return this.setActiveAccount()}async setColorMode(e){return Q(e)}async getColorMode(){return we()}async getAppMetadata(){return this.getOwnAppMetadata()}async showPrepare(){const e=await(async()=>{try{return await this.getWalletInfo()}catch{return}})();await this.events.emit(g.SHOW_PREPARE,{walletInfo:e})}async hideUI(e,t){var i,n,a,r;if(await this.events.emit(g.HIDE_UI,["alert","toast"]),e.includes("alert")){const l=await this.transport;if(!t||l.type===t)await Promise.all([(i=this.postMessageTransport)==null?void 0:i.disconnect(),(n=this.walletConnectTransport)==null?void 0:n.disconnect()]),this._initPromise=void 0;else switch(t){case M.WALLETCONNECT:(a=this.walletConnectTransport)==null||a.disconnect();break;default:(r=this.postMessageTransport)==null||r.disconnect()}}}async removeAccount(e){const t=super.removeAccount(e),i=await this.getActiveAccount();return i&&i.accountIdentifier===e&&await this.setActiveAccount(void 0),t}async removeAllAccounts(){await super.removeAllAccounts(),await this.setActiveAccount(void 0)}async removePeer(e,t=!1){const i=await this.transport,n=i.removePeer(e);return await this.removeAccountsForPeers([e]),t&&await this.sendDisconnectToPeer(e,i),n}async removeAllPeers(e=!1){const t=await this.transport,i=await t.getPeers(),n=t.removeAllPeers();if(await this.removeAccountsForPeers(i),e){const a=i.map(r=>this.sendDisconnectToPeer(r,t));await Promise.all(a)}return n}async subscribeToEvent(e,t){e===g.ACTIVE_ACCOUNT_SET&&(this.isGetActiveAccountHandled=!0),await this.events.on(e,t)}async checkPermissions(e){if([u.PermissionRequest,u.ProofOfEventChallengeRequest,u.ProofOfEventChallengeRecorded].includes(e))return!0;const t=await this.getActiveAccount();if(!t)throw await this.sendInternalError("No active account set!");const i=t.scopes;switch(e){case u.OperationRequest:return i.includes(N.OPERATION_REQUEST);case u.SignPayloadRequest:return i.includes(N.SIGN);case u.BroadcastRequest:return!0;default:return!1}}async sendNotification(e,t,i,n){var l,o,p;const a=await this.getActiveAccount();if(!a||a&&!a.scopes.includes(N.NOTIFICATION)&&!a.notification)throw new Error("notification permissions not given");if(!((l=a.notification)!=null&&l.token))throw new Error("No AccessToken");const r=(o=a.notification)==null?void 0:o.apiUrl;if(!r)throw new Error("No Push URL set");return this.sendNotificationWithAccessToken({url:r,recipient:a.address,title:e,body:t,payload:i,protocolIdentifier:n,accessToken:(p=a.notification)==null?void 0:p.token})}addBlockchain(e){this.blockchains.set(e.identifier,e),e.getWalletLists().then(t=>{ge(t.desktopList),fe(t.extensionList),ye(t.webList),Ae(t.iOSList)})}removeBlockchain(e){this.blockchains.delete(e)}async permissionRequest(e){c.log("permissionRequest",e);const t=this.blockchains.get(e.blockchainIdentifier);if(!t)throw new Error(`Blockchain "${e.blockchainIdentifier}" not supported by dAppClient`);const i={...e,type:u.PermissionRequest,blockchainData:{...e.blockchainData,appMetadata:await this.getOwnAppMetadata()}};c.log("REQUESTION PERMIMISSION V3","xxx",i);const{message:n,connectionInfo:a}=await this.makeRequestV3(i).catch(async o=>{throw new Error("TODO")});c.log("RESPONSE V3",n,a);const r=await t.getAccountInfosFromPermissionResponse(n.message),l={accountIdentifier:r[0].accountId,senderId:n.senderId,origin:{type:a.origin,id:a.id},address:r[0].address,publicKey:r[0].publicKey,scopes:n.message.blockchainData.scopes,connectedAt:new Date().getTime(),chainData:n.message.blockchainData};return await this.accountManager.addAccount(l),await this.setActiveAccount(l),await t.handleResponse({request:i,account:l,output:n,blockExplorer:this.blockExplorer,connectionContext:a,walletInfo:await this.getWalletInfo()}),await this.notifySuccess(i,{account:l,output:{address:r[0].address,network:{type:A.MAINNET},scopes:[N.OPERATION_REQUEST]},blockExplorer:this.blockExplorer,connectionContext:a,walletInfo:await this.getWalletInfo()}),n.message}async request(e){c.log("request",e);const t=this.blockchains.get(e.blockchainIdentifier);if(!t)throw new Error(`Blockchain "${t}" not supported by dAppClient`);await t.validateRequest(e);const i=await this.getActiveAccount();if(!i)throw await this.sendInternalError("No active account!");const n={...e,type:u.BlockchainRequest,accountId:i.accountIdentifier},{message:a,connectionInfo:r}=await this.makeRequestV3(n).catch(async l=>{throw console.error(l),new Error("TODO")});return await t.handleResponse({request:n,account:i,output:a,blockExplorer:this.blockExplorer,connectionContext:r,walletInfo:await this.getWalletInfo()}),a.message}async requestPermissions(e){var l;(e==null?void 0:e.network)!==void 0&&this.network.type!==((l=e==null?void 0:e.network)==null?void 0:l.type)&&console.error("[BEACON] The network specified in the DAppClient constructor does not match the network set in the permission request. Please set the network in the constructor. Setting it during the Permission Request is deprecated.");const t={appMetadata:await this.getOwnAppMetadata(),type:u.PermissionRequest,network:this.network,scopes:e&&e.scopes?e.scopes:[N.OPERATION_REQUEST,N.SIGN]};this.analytics.track("event","DAppClient","Permission requested");const{message:i,connectionInfo:n}=await this.makeRequest(t).catch(async o=>{throw await this.handleRequestError(t,o)});c.log("requestPermissions","######## MESSAGE #######"),c.log("requestPermissions",i);const a=await this.onNewAccount(i,n);c.log("requestPermissions","######## ACCOUNT INFO #######"),c.log("requestPermissions",JSON.stringify(a)),await this.accountManager.addAccount(a),await this.setActiveAccount(a);const r={...i,walletKey:a.walletKey,address:a.address,accountInfo:a};return await this.notifySuccess(t,{account:a,output:r,blockExplorer:this.blockExplorer,connectionContext:n,walletInfo:await this.getWalletInfo()}),this.analytics.track("event","DAppClient","Permission received",{address:a.address}),r}async requestProofOfEventChallenge(e){const t=await this.getActiveAccount();if(!t)throw new Error("Please request permissions before doing a proof of event challenge");if(t.walletType!=="abstracted_account"&&t.verificationType!=="proof_of_event")throw new Error("This wallet is not an abstracted account and thus cannot perform proof of event");const i={type:u.ProofOfEventChallengeRequest,contractAddress:t.address,...e},{message:n,connectionInfo:a}=await this.makeRequest(i).catch(async r=>{throw await this.handleRequestError(i,r)});return this.analytics.track("event","DAppClient",`Proof of event challenge ${n.isAccepted?"accepted":"refused"}`,{address:t.address}),n.isAccepted&&await this.recordProofOfEventChallenge(e),await this.notifySuccess(i,{account:t,output:n,blockExplorer:this.blockExplorer,connectionContext:a,walletInfo:await this.getWalletInfo()}),n}async recordProofOfEventChallenge(e){if(!await this.getActiveAccount())throw new Error("Active account is undefined. Please request permissions before recording a proof of event challenge");const a={type:u.ProofOfEventChallengeRecorded,dAppChallengeId:e.dAppChallengeId,success:!0,errorMessage:""};await this.makeRequest(a,!0).catch(async r=>{throw await this.handleRequestError(a,r)})}async requestSignPayload(e){if(!e.payload)throw await this.sendInternalError("Payload must be provided");const t=await this.getActiveAccount();if(!t)throw await this.sendInternalError("No active account!");const i=e.payload;if(typeof i!="string")throw new Error("Payload must be a string");const n=(()=>{switch(e.signingType){case k.OPERATION:if(!i.startsWith("03"))throw new Error('When using signing type "OPERATION", the payload must start with prefix "03"');return k.OPERATION;case k.MICHELINE:if(!i.startsWith("05"))throw new Error('When using signing type "MICHELINE", the payload must start with prefix "05"');return k.MICHELINE;case k.RAW:default:return k.RAW}})();this.analytics.track("event","DAppClient","Signature requested");const a={type:u.SignPayloadRequest,signingType:n,payload:i,sourceAddress:e.sourceAddress||t.address},{message:r,connectionInfo:l}=await this.makeRequest(a).catch(async o=>{throw await this.handleRequestError(a,o)});return await this.notifySuccess(a,{account:t,output:r,connectionContext:l,walletInfo:await this.getWalletInfo()}),this.analytics.track("event","DAppClient","Signature response"),r}async requestOperation(e){if(!e.operationDetails)throw await this.sendInternalError("Operation details must be provided");const t=await this.getActiveAccount();if(!t)throw await this.sendInternalError("No active account!");const i={type:u.OperationRequest,network:t.network||this.network,operationDetails:e.operationDetails,sourceAddress:t.address||""};this.analytics.track("event","DAppClient","Operation requested");const{message:n,connectionInfo:a}=await this.makeRequest(i).catch(async r=>{throw await this.handleRequestError(i,r)});return await this.notifySuccess(i,{account:t,output:n,blockExplorer:this.blockExplorer,connectionContext:a,walletInfo:await this.getWalletInfo()}),this.analytics.track("event","DAppClient","Operation response"),n}async requestBroadcast(e){var a;if(!e.signedTransaction)throw await this.sendInternalError("Signed transaction must be provided");e.network!==void 0&&this.network.type!==((a=e.network)==null?void 0:a.type)&&console.error("[BEACON] The network specified in the DAppClient constructor does not match the network set in the broadcast request. Please set the network in the constructor. Setting it during the Broadcast Request is deprecated.");const t={type:u.BroadcastRequest,network:this.network,signedTransaction:e.signedTransaction};this.analytics.track("event","DAppClient","Broadcast requested");const{message:i,connectionInfo:n}=await this.makeRequest(t).catch(async r=>{throw await this.handleRequestError(t,r)});return await this.notifySuccess(t,{network:this.network,output:i,blockExplorer:this.blockExplorer,connectionContext:n,walletInfo:await this.getWalletInfo()}),this.analytics.track("event","DAppClient","Broadcast response"),i}async setActivePeer(e){this._activePeer.isSettled()?this._activePeer=C.resolve(e):this._activePeer.resolve(e),e&&(await this.initInternalTransports(),e.type==="postmessage-pairing-response"?await this.setTransport(this.postMessageTransport):e.type==="p2p-pairing-response"&&await this.setTransport(this.p2pTransport))}async setTransport(e){e||(this._initPromise=void 0);const t=super.setTransport(e);return await this.events.emit(g.ACTIVE_TRANSPORT_SET,e),t}async sendInternalError(e){throw await this.events.emit(g.INTERNAL_ERROR,{text:e}),new Error(e)}async removeAccountsForPeers(e){const t=e.map(i=>i.senderId);return this.removeAccountsForPeerIds(t)}async removeAccountsForPeerIds(e){const n=(await this.accountManager.getAccounts()).filter(r=>e.includes(r.senderId)).map(r=>r.accountIdentifier);await this.accountManager.removeAccounts(n);const a=await this.getActiveAccount();a&&n.includes(a.accountIdentifier)&&await this.setActiveAccount(void 0)}async handleRequestError(e,t){if(c.error("handleRequestError","error response",t),t.errorType){const i=[];if(t.errorType===J.NO_PRIVATE_KEY_FOUND_ERROR){const r=async()=>{const l=e;let o;if(l.sourceAddress&&l.network){const p=await z(l.sourceAddress,l.network);o=await this.getAccount(p),o&&await this.removeAccount(o.accountIdentifier)}};i.push({text:"Remove account",actionCallback:r})}const n=await this.getPeer(),a=await this.getActiveAccount();throw e.type===u.PermissionRequest&&await this.getActiveAccount()===void 0&&(this._initPromise=void 0,this.postMessageTransport=void 0,this.p2pTransport=void 0,this.walletConnectTransport=void 0,await this.setTransport(),await this.setActivePeer()),this.events.emit(q[e.type].error,{errorResponse:t,walletInfo:await this.getWalletInfo(n,a),errorMessages:this.errorMessages},i).catch(r=>c.error("handleRequestError",r)),me.getError(t.errorType,t.errorData)}throw t}async notifySuccess(e,t){this.events.emit(q[e.type].success,t).catch(i=>console.warn(i))}async getWalletInfoFromStorage(){return await this.storage.get(P.LAST_SELECTED_WALLET)}async getWalletInfo(e,t){const i=t||await this.getActiveAccount(),n=e||await this.getPeer(i);let a;i&&(a=await this.appMetadataManager.getAppMetadata(i.senderId)),a||(a={name:(n==null?void 0:n.name)??await this.getWalletInfoFromStorage()??"",icon:n==null?void 0:n.icon});const r=(y,R)=>y&&R?y.toLowerCase()===R.toLowerCase():!1,l=y=>y.split(/[_\s]+/)[0];let o,p;const f=[...Pe(),...Ee(),...Te(),...ve()].filter(y=>r(l(y.key),l((a==null?void 0:a.name)??"wallet"))),E=f.find(y=>y.universalLink),T=f.find(y=>y.links),h=f.find(y=>y.downloadLink),m=f.find(y=>y.id);if(X(window)&&T?(o=T,p="web"):Ie(window)&&h?(o=h,p="desktop"):X(window)&&m?(o=m,p="extension"):E&&(o=E,p="mobile"),o){let y;return o.hasOwnProperty("links")?y=o.links[(i==null?void 0:i.network.type)??this.network.type]:o.hasOwnProperty("deepLink")&&(y=o.deepLink),{name:(o==null?void 0:o.name)??a.name,icon:(o==null?void 0:o.logo)??a.icon,deeplink:y,type:p}}return a}async getPeer(e){var i,n,a;let t;if(e){c.log("getPeer","We have an account",e);const r=await((i=this.postMessageTransport)==null?void 0:i.getPeers())??[],l=await((n=this.p2pTransport)==null?void 0:n.getPeers())??[],o=await((a=this.walletConnectTransport)==null?void 0:a.getPeers())??[],p=[...r,...l,...o];c.log("getPeer","Found peers",p,e),t=p.find(f=>f.senderId===e.senderId),t||(t=p.find(f=>f.extensionId===e.origin.id))}else t=await this._activePeer.promise,c.log("getPeer","Active peer",t);return t}async makeRequest(e,t){var E,T;const i=await x();this._initPromise&&this.isInitPending&&(await Promise.all([(E=this.postMessageTransport)==null?void 0:E.disconnect(),(T=this.walletConnectTransport)==null?void 0:T.disconnect()]),this._initPromise=void 0,this.hideUI(["toast"])),c.time(!0,i),c.log("makeRequest","starting"),this.isInitPending=!0,await this.init(),this.isInitPending=!1,c.timeLog(i,"init done"),c.log("makeRequest","after init");const n=await this.transport;if(n instanceof D&&await this.getActiveAccount()&&!await n.hasPairings()&&!await n.hasSessions())throw await this.channelClosedHandler(n.type),new Error("No active pairing nor session found");if(await this.addRequestAndCheckIfRateLimited())throw this.events.emit(g.LOCAL_RATE_LIMIT_REACHED).catch(h=>console.warn(h)),new Error("rate limit reached");if(!await this.checkPermissions(e.type))throw this.events.emit(g.NO_PERMISSIONS).catch(h=>console.warn(h)),new Error("No permissions to send this request to wallet!");if(!this.beaconId)throw await this.sendInternalError("BeaconID not defined");const a={id:i,version:"2",senderId:await W(await this.beaconId),...e};let r;t||(r=new C,this.addOpenRequest(a.id,r));const l=await new U().serialize(a),o=await this.getActiveAccount(),p=await this.getPeer(o),f=await this.getWalletInfo(p,o);c.log("makeRequest","sending message",a),c.timeLog("makeRequest",i,"sending");try{await n.send(l,p)}catch(h){throw this.events.emit(g.INTERNAL_ERROR,{text:"Unable to send message. If this problem persists, please reset the connection and pair your wallet again.",buttons:[{text:"Reset Connection",actionCallback:async()=>{await Y(),this.disconnect()}}]}),c.timeLog("makeRequest",i,"send error"),h}return c.timeLog("makeRequest",i,"sent"),this.events.emit(q[e.type].sent,{walletInfo:{...f,name:f.name??"Wallet"},extraInfo:{resetCallback:async()=>{this.disconnect()}}}).catch(h=>console.warn(h)),r==null?void 0:r.promise}async makeRequestV3(e){var E,T;this._initPromise&&this.isInitPending&&(await Promise.all([(E=this.postMessageTransport)==null?void 0:E.disconnect(),(T=this.walletConnectTransport)==null?void 0:T.disconnect()]),this._initPromise=void 0,this.hideUI(["toast"]));const t=await x();if(c.time(!0,t),c.log("makeRequest","starting"),this.isInitPending=!0,await this.init(),this.isInitPending=!1,c.timeLog("makeRequest",t,"init done"),c.log("makeRequest","after init"),await this.addRequestAndCheckIfRateLimited())throw this.events.emit(g.LOCAL_RATE_LIMIT_REACHED).catch(h=>console.warn(h)),new Error("rate limit reached");const i=await this.transport;if(i instanceof D&&await this.getActiveAccount()&&!await i.hasPairings()&&!await i.hasSessions())throw await this.channelClosedHandler(i.type),new Error("No active pairing nor session found");if(!this.beaconId)throw await this.sendInternalError("BeaconID not defined");const n={id:t,version:"3",senderId:await W(await this.beaconId),message:e},a=new C;this.addOpenRequest(n.id,a);const r=await new U().serialize(n),l=await this.getActiveAccount(),o=await this.getPeer(l),p=await this.getWalletInfo(o,l);c.log("makeRequest","sending message",n),c.timeLog("makeRequest",t,"sending");try{await i.send(r,o)}catch(h){throw this.events.emit(g.INTERNAL_ERROR,{text:"Unable to send message. If this problem persists, please reset the connection and pair your wallet again.",buttons:[{text:"Reset Connection",actionCallback:async()=>{await Y(),this.disconnect()}}]}),c.timeLog("makeRequest",t,"send error"),h}c.timeLog("makeRequest",t,"sent");const f=e.type;return this.events.emit(q[f].sent,{walletInfo:{...p,name:p.name??"Wallet"},extraInfo:{resetCallback:async()=>{this.disconnect()}}}).catch(h=>console.warn(h)),a.promise}async disconnect(){this.postMessageTransport=void 0,this.p2pTransport=void 0,this.walletConnectTransport=void 0,await Promise.all([this.clearActiveAccount(),(await this.transport).disconnect()])}addOpenRequest(e,t){c.log("addOpenRequest",this.name,`adding request ${e} and waiting for answer`),this.openRequests.set(e,t)}async sendNotificationWithAccessToken(e){const{url:t,recipient:i,title:n,body:a,payload:r,protocolIdentifier:l,accessToken:o}=e,p=new Date().toISOString(),f=await this.keyPair,E=f.publicKey,T=Buffer.from(new Uint8Array([13,15,37,217])),h=Se.encode(Buffer.concat([T,Buffer.from(E)])),m=["Tezos Signed Message: ",i,n,a,p,r].join(" "),y=ee(m),R="0501"+y.length.toString(16).padStart(8,"0")+y,_=await Ce(R,{secretKey:Buffer.from(f.secretKey)});return(await Le.post(`${t}/send`,{recipient:i,title:n,body:a,timestamp:p,payload:r,accessToken:o,protocolIdentifier:l,sender:{name:this.name,publicKey:h,signature:_}})).data}async onNewAccount(e,t){const i=e.publicKey||e.pubkey||e.pubKey,n=i?await Re(i):void 0;if(!n&&!e.address)throw new Error("PublicKey or Address must be defined");const a=e.address??await ke(n);if(!Ne(a))throw new Error(`Invalid address: "${a}"`);if(e.walletType==="abstracted_account"&&a.substring(0,3)!==Z)throw new Error(`Invalid abstracted account address "${a}", it should be a ${Z} address`);c.log("######## MESSAGE #######"),c.log("onNewAccount",e);const r=await this.storage.get(P.LAST_SELECTED_WALLET),l={accountIdentifier:await z(a,e.network),senderId:e.senderId,origin:{type:t.origin,id:t.id},walletKey:r,address:a,publicKey:n,network:e.network,scopes:e.scopes,threshold:e.threshold,notification:e.notification,connectedAt:new Date().getTime(),walletType:e.walletType??"implicit",verificationType:e.verificationType,...e.verificationType==="proof_of_event"?{hasVerifiedChallenge:!1}:{}};return c.log("accountInfo","######## ACCOUNT INFO #######"),c.log("accountInfo",l),await this.accountManager.addAccount(l),await this.setActiveAccount(l),l}}let O;const st=(w,s)=>(O&&s&&(O.disconnect(),O=void 0),O||(O||(O=new tt(w)),O));function I(w,s,e,t){function i(n){return n instanceof e?n:new e(function(a){a(n)})}return new(e||(e=Promise))(function(n,a){function r(p){try{o(t.next(p))}catch(f){a(f)}}function l(p){try{o(t.throw(p))}catch(f){a(f)}}function o(p){p.done?n(p.value):i(p.value).then(r,l)}o((t=t.apply(w,s||[])).next())})}class H extends ae{constructor(){super(),this.name="BeaconWalletNotInitialized",this.message='BeaconWallet needs to be initialized by calling `await BeaconWallet.requestPermissions({network: {type: "chosen_network"}})` first.'}}class nt extends ae{constructor(s){super(),this.requiredScopes=s,this.name="MissingRequiredScopes",this.message=`Required permissions scopes: ${s.join(",")} were not granted.`}}const lt={commitHash:"bb48f61207e1806442b0874365e98c7283ba1f68",version:"19.1.0"};class ht{constructor(s){this.client=st(s)}validateRequiredScopesOrFail(s,e){const t=new Set(e);for(const i of s)t.has(i)&&t.delete(i);if(t.size>0)throw new nt(Array.from(t))}requestPermissions(s){return I(this,void 0,void 0,function*(){yield this.client.requestPermissions(s)})}getPKH(){return I(this,void 0,void 0,function*(){const s=yield this.client.getActiveAccount();if(!s)throw new H;return s.address})}getPK(){var s;return I(this,void 0,void 0,function*(){const e=yield this.client.getActiveAccount();if(!e)throw new H;return(s=e.publicKey)!==null&&s!==void 0?s:""})}mapTransferParamsToWalletParams(s){return I(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield xe(this.formatParameters(e)))})}mapIncreasePaidStorageWalletParams(s){return I(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield We(this.formatParameters(e)))})}mapOriginateParamsToWalletParams(s){return I(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield Ue(this.formatParameters(e)))})}mapDelegateParamsToWalletParams(s){return I(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield Be(this.formatParameters(e)))})}formatParameters(s){return s.fee&&(s.fee=s.fee.toString()),s.storageLimit&&(s.storageLimit=s.storageLimit.toString()),s.gasLimit&&(s.gasLimit=s.gasLimit.toString()),s}removeDefaultParams(s,e){return s.fee||delete e.fee,s.storageLimit||delete e.storage_limit,s.gasLimit||delete e.gas_limit,e}sendOperations(s){return I(this,void 0,void 0,function*(){const e=yield this.client.getActiveAccount();if(!e)throw new H;const t=e.scopes;this.validateRequiredScopesOrFail(t,[N.OPERATION_REQUEST]);const{transactionHash:i}=yield this.client.requestOperation({operationDetails:s});return i})}disconnect(){return I(this,void 0,void 0,function*(){yield this.client.destroy()})}clearActiveAccount(){return I(this,void 0,void 0,function*(){yield this.client.setActiveAccount()})}sign(s,e){return I(this,void 0,void 0,function*(){let t=_e(s);typeof e<"u"&&(t=Me(e,t));const i=be(qe(t)),n=this.getSigningType(e);if(n!==k.OPERATION)throw new De(`Taquito Beacon Wallet currently only supports signing operations, not ${n}`);const{signature:a}=yield this.client.requestSignPayload({payload:i,signingType:n});return a})}getSigningType(s){if(!s||s.length===0)return k.RAW;if(s.length===1){if(s[0]===5)return k.MICHELINE;if(s[0]===3)return k.OPERATION}throw new Error(`Invalid watermark ${JSON.stringify(s)}`)}}export{ht as BeaconWallet,H as BeaconWalletNotInitialized,nt as MissingRequiredScopes,lt as VERSION};
