import{p as o,M as v,V as S,N as z,c as T,Q as O,R as K,U as w,W as f,X as A,Y as U,Z as _,$ as R,b as k,a as B,_ as I,E as N,z as $,A as F,O as l,K as P,B as D}from"./main-93137ffa.js";import{S as V}from"./SessionBase-9705d86c.js";import{H,a as b,S as y}from"./taquito.es6-bc2c6d4a.js";import"./DAppClient-5a7f0f36.js";function u(a,t,e,s){function i(n){return n instanceof e?n:new e(function(r){r(n)})}return new(e||(e=Promise))(function(n,r){function c(p){try{d(s.next(p))}catch(g){r(g)}}function h(p){try{d(s.throw(p))}catch(g){r(g)}}function d(p){p.done?n(p.value):i(p.value).then(c,h)}d((s=s.apply(a,t||[])).next())})}class E extends Error{constructor(t,e){super(t),this.message=t,this.innerException=e,this.name="KeyNotFoundError"}}class q extends Error{constructor(t,e){super(t),this.message=t,this.innerException=e,this.name="OperationNotAuthorized"}}class L extends Error{constructor(t,e,s){super(t),this.message=t,this.innerException=e,this.data=s,this.name="BadSigningData"}}class j extends Error{constructor(t,e){super(`Requested public key hash does not match the initialized public key hash: {
        requested: ${t},
        initialized: ${e}
      }`),this.requested=t,this.name="PublicKeyMismatch"}}class M extends Error{constructor(t,e){super(`
        Signature failed verification against public key: 
        {
          bytes: ${t},
          signature: ${e}
        }
      `),this.bytes=t,this.signature=e,this.name="SignatureVerificationFailedError"}}const x={ed:{pk:o.edpk,sk:o.edsk,pkh:o.tz1,sig:o.edsig},p2:{pk:o.p2pk,sk:o.p2sk,pkh:o.tz3,sig:o.p2sig},sp:{pk:o.sppk,sk:o.spsk,pkh:o.tz2,sig:o.spsig}};class C{constructor(t,e,s={},i=new H){if(this.pkh=t,this.rootUrl=e,this.options=s,this.http=i,v(this.pkh)!==S.VALID)throw new z(this.pkh)}publicKeyHash(){return u(this,void 0,void 0,function*(){return this.pkh})}createURL(t){return`${this.rootUrl.replace(/\/+$/g,"")}${t}`}publicKey(){return u(this,void 0,void 0,function*(){try{const{public_key:t}=yield this.http.createRequest({url:this.createURL(`/keys/${this.pkh}`),method:"GET",headers:this.options.headers});return t}catch(t){throw t instanceof b&&t.status===y.NOT_FOUND?new E(`Key not found: ${this.pkh}`,t):t}})}secretKey(){return u(this,void 0,void 0,function*(){throw new T("Secret key cannot be exposed")})}sign(t,e){return u(this,void 0,void 0,function*(){try{let s=O(t);typeof e<"u"&&(s=K(e,s));const i=w(f(s)),{signature:n}=yield this.http.createRequest({url:this.createURL(`/keys/${this.pkh}`),method:"POST",headers:this.options.headers},i),r=n.startsWith("sig")?n.substring(0,3):n.substring(0,5);if(!A(r))throw new U(n,"Unsupported signature given by remote signer");const c=_(n,o[r]),h=yield this.publicKey();if(yield this.verifyPublicKey(h),!R(i,h,n))throw new M(i,n);return{bytes:t,sig:k(c,o.sig),prefixSig:n,sbytes:t+w(f(c))}}catch(s){if(s instanceof b){if(s.status===y.NOT_FOUND)throw new E(`Key not found: ${this.pkh}`,s);if(s.status===y.FORBIDDEN)throw new q("Signing Operation not authorized",s);if(s.status===y.BAD_REQUEST)throw new L("Invalid data",s,{bytes:t,watermark:e})}throw s}})}verifyPublicKey(t){return u(this,void 0,void 0,function*(){const e=t.substring(0,2),s=_(t,x[e].pk),i=k(B.hash(s,20),x[e].pkh);if(i!==this.pkh)throw new j(i,this.pkh)})}}const W=async(a,t,e)=>{const{create_toolkit:s}=await I(()=>import("./taquito-76b8663f.js"),["assets/taquito-76b8663f.js","assets/taquito.es6-bc2c6d4a.js","assets/main-93137ffa.js","assets/index-3496dcff.css","assets/DAppClient-5a7f0f36.js"]),{tezos:i,forger:n}=await s(e.rpc),r=new C(a,t);i.setSignerProvider(r);const c=a,h=c?await i.rpc.getManagerKey(c):void 0;return{account:c,tezos:i,forger:n,managerKey:h==null?void 0:h.toString()}},{request_ledger_setup:Q}=P();class m extends V{constructor(t,e,s,i,n){super(t,s,i,n),this.url=e}get AccountType(){return N.Remote}get Icon(){return new $("cloud",F.icon)}get IsAccountSwitchSupported(){return!1}static async create(t,e,s,i){const n=D[s];if(!n)throw new Error("Invalid network specification!");const{tezos:r,forger:c,managerKey:h}=await W(t,e,{...i,rpc:(i==null?void 0:i.rpc)??n.rpc});return new m(t,e,r,c,{networkId:s,managerKey:h})}static async create_from_cache(){}logout(){}async switch_wallet(){const t=await Q({networkId:this.NetworkId,rpc:this.Tezos.rpc.getRpcUrl()});if(!t)throw new Error("Aborted.");return t}async vote(t){const e=await this.forge_ballot_op(t),s=async()=>{const i=this.Tezos.wallet.context,n=await this.Tezos.signer.sign(e,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(n.sbytes);return i.operationFactory.createOperation(r)};return new l(s,"Vote",{account:this.Account,ballot:t})}async propose(t){const e=await this.forge_proposals_op(t),s=async()=>{const i=this.Tezos.wallet.context,n=await this.Tezos.signer.sign(e,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(n.sbytes);return i.operationFactory.createOperation(r)};return new l(s,"Propose",{account:this.Account,proposals:t})}async set_deposits_limit(t){const e=await this.forge_set_deposit_op(t),s=async()=>{const i=this.Tezos.wallet.context,n=await this.Tezos.signer.sign(e,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(n.sbytes);return i.operationFactory.createOperation(r)};return new l(s,"Propose",{account:this.Account,limit:t.toString()})}async update_consensus_key(t){const e=await this.forge_update_consensus_key_op(t),s=async()=>{const i=this.Tezos.wallet.context,n=await this.Tezos.signer.sign(e,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(n.sbytes);return i.operationFactory.createOperation(r)};return new l(s,"Propose",{account:this.Account,"Consensus Key":t})}}export{m as RemoteSession};
