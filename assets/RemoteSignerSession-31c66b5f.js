import{p as o,W as z,V as f,X as O,i as _,Y as k,d as A,Z as K,$ as I,a0 as m,a1 as b,a2 as R,a3 as U,a4 as E,a5 as P,b as v,c as V,a6 as B,T as y,_ as D,E as F,G as N,H as $,O as u,U as H,J as j}from"./main-5a3da669.js";import{S as q}from"./SessionBase-241765a6.js";import{H as C,a as T,S as l}from"./taquito.es6-2b3fad54.js";import"./DAppClient-2a387e18.js";function d(h,t,s,e){function n(i){return i instanceof s?i:new s(function(r){r(i)})}return new(s||(s=Promise))(function(i,r){function a(p){try{g(e.next(p))}catch(w){r(w)}}function c(p){try{g(e.throw(p))}catch(w){r(w)}}function g(p){p.done?i(p.value):n(p.value).then(a,c)}g((e=e.apply(h,t||[])).next())})}class L extends B{constructor(t,s){super(),this.message=t,this.cause=s,this.name="OperationNotAuthorized"}}class W extends y{constructor(t,s,e){super(),this.cause=t,this.bytes=s,this.watermark=e,this.name="BadSigningData",this.message=e?"Invalid signing data with watermark":`Invalid signing data: "${s}"`}}class G extends y{constructor(t,s,e){super(),this.requestedPk=t,this.requestedPkh=s,this.initializedPkh=e,this.name="PublicKeyVerificationFailedError",this.message=`Requested pk "${t}" has pkh "${s}" deesn't match initialized pkh "${e}."`}}class M extends y{constructor(t,s){super(),this.bytes=t,this.signature=s,this.name="SignatureVerificationFailedError",this.name="SignatureVerificationFailedError",this.message="Invalid signature of bytes failed verification agaisnt public key."}}const S={ed:{pk:o.edpk,sk:o.edsk,pkh:o.tz1,sig:o.edsig},p2:{pk:o.p2pk,sk:o.p2sk,pkh:o.tz3,sig:o.p2sig},sp:{pk:o.sppk,sk:o.spsk,pkh:o.tz2,sig:o.spsig}};class X{constructor(t,s,e={},n=new C){this.pkh=t,this.rootUrl=s,this.options=e,this.http=n;const i=z(this.pkh);if(i!==f.VALID)throw new O(this.pkh,_(i))}publicKeyHash(){return d(this,void 0,void 0,function*(){return this.pkh})}createURL(t){return`${this.rootUrl.replace(/\/+$/g,"")}${t}`}publicKey(){return d(this,void 0,void 0,function*(){try{const{public_key:t}=yield this.http.createRequest({url:this.createURL(`/keys/${this.pkh}`),method:"GET",headers:this.options.headers});return t}catch(t){throw t instanceof T&&t.status===l.NOT_FOUND?new k(this.pkh,t):t}})}secretKey(){return d(this,void 0,void 0,function*(){throw new A("Secret key cannot be exposed")})}sign(t,s){return d(this,void 0,void 0,function*(){try{let e=K(t);typeof s<"u"&&(e=I(s,e));const n=m(b(e)),{signature:i}=yield this.http.createRequest({url:this.createURL(`/keys/${this.pkh}`),method:"POST",headers:this.options.headers},n),r=i.startsWith("sig")?i.substring(0,3):i.substring(0,5);if(!R(r))throw new U(i,_(f.NO_PREFIX_MATCHED)+" from a remote signer.");const a=E(i,o[r]),c=yield this.publicKey();if(yield this.verifyPublicKey(c),!P(n,c,i))throw new M(n,i);return{bytes:t,sig:v(a,o.sig),prefixSig:i,sbytes:t+m(b(a))}}catch(e){if(e instanceof T){if(e.status===l.NOT_FOUND)throw new k(this.pkh,e);if(e.status===l.FORBIDDEN)throw new L("Signing Operation not authorized",e);if(e.status===l.BAD_REQUEST)throw new W(e,t,s)}throw e}})}verifyPublicKey(t){return d(this,void 0,void 0,function*(){const s=t.substring(0,2),e=E(t,S[s].pk),n=v(V.hash(e,20),S[s].pkh);if(n!==this.pkh)throw new G(t,n,this.pkh)})}}const J=async(h,t,s)=>{const{create_toolkit:e}=await D(()=>import("./taquito-8f44c852.js"),["assets/taquito-8f44c852.js","assets/taquito.es6-2b3fad54.js","assets/main-5a3da669.js","assets/index-0559bf31.css"]),{tezos:n,forger:i}=await e(s.rpc),r=new X(h,t);n.setSignerProvider(r);const a=h,c=a?await n.rpc.getManagerKey(a):void 0;return{account:a,tezos:n,forger:i,managerKey:c==null?void 0:c.toString()}},{request_ledger_setup:Q}=H();class x extends q{constructor(t,s,e,n,i){super(t,e,n,i),this.url=s}get AccountType(){return F.Remote}get Icon(){return new N("cloud",$.icon)}get IsAccountSwitchSupported(){return!1}static async create(t,s,e,n){const i=j[e];if(!i)throw new Error("Invalid network specification!");const{tezos:r,forger:a,managerKey:c}=await J(t,s,{...n,rpc:(n==null?void 0:n.rpc)??i.rpc});return new x(t,s,r,a,{networkId:e,managerKey:c})}static async create_from_cache(){}logout(){}async switch_wallet(){const t=await Q({networkId:this.NetworkId,rpc:this.Tezos.rpc.getRpcUrl()});if(!t)throw new Error("Aborted.");return t}async vote(t){const s=await this.forge_ballot_op(t),e=async()=>{const n=this.Tezos.wallet.context,i=await this.Tezos.signer.sign(s,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(i.sbytes);return n.operationFactory.createOperation(r)};return new u(e,"Vote",{account:this.Account,ballot:t})}async propose(t){const s=await this.forge_proposals_op(t),e=async()=>{const n=this.Tezos.wallet.context,i=await this.Tezos.signer.sign(s,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(i.sbytes);return n.operationFactory.createOperation(r)};return new u(e,"Propose",{account:this.Account,proposals:t})}async set_deposits_limit(t){const s=await this.forge_set_deposit_op(t),e=async()=>{const n=this.Tezos.wallet.context,i=await this.Tezos.signer.sign(s,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(i.sbytes);return n.operationFactory.createOperation(r)};return new u(e,"Propose",{account:this.Account,limit:t.toString()})}async update_consensus_key(t){const s=await this.forge_update_consensus_key_op(t),e=async()=>{const n=this.Tezos.wallet.context,i=await this.Tezos.signer.sign(s,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(i.sbytes);return n.operationFactory.createOperation(r)};return new u(e,"Propose",{account:this.Account,"Consensus Key":t})}async restore_consensus_key(){const t=await this.Tezos.signer.publicKey(),s=await this.forge_update_consensus_key_op(t),e=async()=>{const n=this.Tezos.wallet.context,i=await this.Tezos.signer.sign(s,new Uint8Array([3])),r=await this.Tezos.rpc.injectOperation(i.sbytes);return n.operationFactory.createOperation(r)};return new u(e,"Restore consensus key",{account:this.Account,"Consensus Key":t})}}export{x as RemoteSession};
