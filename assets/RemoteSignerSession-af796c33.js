import{E as v,m as S,q as T,v as z,O as l,D as O}from"./main-043506b6.js";import{S as K}from"./SessionBase-d64d9027.js";import{p as o,n as A,V as U,u as R,e as I,Q as B,R as D,r as g,S as w,T as F,U as N,l as _,W as P,c as k,d as $,_ as V}from"./taquito-utils.es6-82c03c39.js";import{H,c as m,S as y}from"./taquito.es6-a47a8eec.js";import"./_commonjsHelpers-6dff16f2.js";import"./DAppClient-8558df6f.js";import"./index-9aada285.js";import"./index-6f227088.js";function u(a,t,e,s){function i(r){return r instanceof e?r:new e(function(n){n(r)})}return new(e||(e=Promise))(function(r,n){function c(p){try{d(s.next(p))}catch(f){n(f)}}function h(p){try{d(s.throw(p))}catch(f){n(f)}}function d(p){p.done?r(p.value):i(p.value).then(c,h)}d((s=s.apply(a,t||[])).next())})}class b extends Error{constructor(t,e){super(t),this.message=t,this.innerException=e,this.name="KeyNotFoundError"}}class q extends Error{constructor(t,e){super(t),this.message=t,this.innerException=e,this.name="OperationNotAuthorized"}}class L extends Error{constructor(t,e,s){super(t),this.message=t,this.innerException=e,this.data=s,this.name="BadSigningData"}}class j extends Error{constructor(t,e){super(`Requested public key hash does not match the initialized public key hash: {
        requested: ${t},
        initialized: ${e}
      }`),this.requested=t,this.name="PublicKeyMismatch"}}class C extends Error{constructor(t,e){super(`
        Signature failed verification against public key: 
        {
          bytes: ${t},
          signature: ${e}
        }
      `),this.bytes=t,this.signature=e,this.name="SignatureVerificationFailedError"}}const E={ed:{pk:o.edpk,sk:o.edsk,pkh:o.tz1,sig:o.edsig},p2:{pk:o.p2pk,sk:o.p2sk,pkh:o.tz3,sig:o.p2sig},sp:{pk:o.sppk,sk:o.spsk,pkh:o.tz2,sig:o.spsig}};class M{constructor(t,e,s={},i=new H){if(this.pkh=t,this.rootUrl=e,this.options=s,this.http=i,A(this.pkh)!==U.VALID)throw new R(this.pkh)}publicKeyHash(){return u(this,void 0,void 0,function*(){return this.pkh})}createURL(t){return`${this.rootUrl.replace(/\/+$/g,"")}${t}`}publicKey(){return u(this,void 0,void 0,function*(){try{const{public_key:t}=yield this.http.createRequest({url:this.createURL(`/keys/${this.pkh}`),method:"GET",headers:this.options.headers});return t}catch(t){throw t instanceof m&&t.status===y.NOT_FOUND?new b(`Key not found: ${this.pkh}`,t):t}})}secretKey(){return u(this,void 0,void 0,function*(){throw new I("Secret key cannot be exposed")})}sign(t,e){return u(this,void 0,void 0,function*(){try{let s=B(t);typeof e<"u"&&(s=D(e,s));const i=g(w(s)),{signature:r}=yield this.http.createRequest({url:this.createURL(`/keys/${this.pkh}`),method:"POST",headers:this.options.headers},i),n=r.startsWith("sig")?r.substring(0,3):r.substring(0,5);if(!F(n))throw new N(r,"Unsupported signature given by remote signer");const c=_(r,o[n]),h=yield this.publicKey();if(yield this.verifyPublicKey(h),!P(i,h,r))throw new C(i,r);return{bytes:t,sig:k(c,o.sig),prefixSig:r,sbytes:t+g(w(c))}}catch(s){if(s instanceof m){if(s.status===y.NOT_FOUND)throw new b(`Key not found: ${this.pkh}`,s);if(s.status===y.FORBIDDEN)throw new q("Signing Operation not authorized",s);if(s.status===y.BAD_REQUEST)throw new L("Invalid data",s,{bytes:t,watermark:e})}throw s}})}verifyPublicKey(t){return u(this,void 0,void 0,function*(){const e=t.substring(0,2),s=_(t,E[e].pk),i=k($.hash(s,20),E[e].pkh);if(i!==this.pkh)throw new j(i,this.pkh)})}}const W=async(a,t,e)=>{const{create_toolkit:s}=await V(()=>import("./taquito-c350d5de.js"),["assets/taquito-c350d5de.js","assets/taquito.es6-a47a8eec.js","assets/taquito-utils.es6-82c03c39.js","assets/_commonjsHelpers-6dff16f2.js","assets/index-9aada285.js","assets/index-6f227088.js"]),{tezos:i,forger:r}=await s(e.rpc),n=new M(a,t);i.setSignerProvider(n);const c=a,h=c?await i.rpc.getManagerKey(c):void 0;return{account:c,tezos:i,forger:r,managerKey:h==null?void 0:h.toString()}},{request_ledger_setup:Q}=O();class x extends K{constructor(t,e,s,i,r){super(t,s,i,r),this.url=e}get AccountType(){return v.Remote}get Icon(){return new S("cloud",T.icon)}get IsAccountSwitchSupported(){return!1}static async create(t,e,s,i){const r=z[s];if(!r)throw new Error("Invalid network specification!");const{tezos:n,forger:c,managerKey:h}=await W(t,e,{...i,rpc:(i==null?void 0:i.rpc)??r.rpc});return new x(t,e,n,c,{networkId:s,managerKey:h})}static async create_from_cache(){}logout(){}async switch_wallet(){const t=await Q({networkId:this.NetworkId,rpc:this.Tezos.rpc.getRpcUrl()});if(!t)throw new Error("Aborted.");return t}async vote(t){const e=await this.forge_ballot_op(t),s=async()=>{const i=this.Tezos.wallet.context,r=await this.Tezos.signer.sign(e,new Uint8Array([3])),n=await this.Tezos.rpc.injectOperation(r.sbytes);return i.operationFactory.createOperation(n)};return new l(s,"Vote",{account:this.Account,ballot:t})}async propose(t){const e=await this.forge_proposals_op(t),s=async()=>{const i=this.Tezos.wallet.context,r=await this.Tezos.signer.sign(e,new Uint8Array([3])),n=await this.Tezos.rpc.injectOperation(r.sbytes);return i.operationFactory.createOperation(n)};return new l(s,"Propose",{account:this.Account,proposals:t})}async set_deposits_limit(t){const e=await this.forge_set_deposit_op(t),s=async()=>{const i=this.Tezos.wallet.context,r=await this.Tezos.signer.sign(e,new Uint8Array([3])),n=await this.Tezos.rpc.injectOperation(r.sbytes);return i.operationFactory.createOperation(n)};return new l(s,"Propose",{account:this.Account,limit:t.toString()})}async update_consensus_key(t){const e=await this.forge_update_consensus_key_op(t),s=async()=>{const i=this.Tezos.wallet.context,r=await this.Tezos.signer.sign(e,new Uint8Array([3])),n=await this.Tezos.rpc.injectOperation(r.sbytes);return i.operationFactory.createOperation(n)};return new l(s,"Propose",{account:this.Account,"Consensus Key":t})}}export{x as RemoteSession};
