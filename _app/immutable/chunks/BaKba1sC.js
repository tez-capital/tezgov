const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./DivCsxyi.js","./Bho5j6Xg.js","./BRl2jpNx.js"])))=>i.map(i=>d[i]);
import{g as v,R as l,c as T}from"./Ch_IHUOo.js";import{c as _}from"./D1u8ypzV.js";import{t as b}from"./trIFHh5f.js";import{_ as R}from"./Bho5j6Xg.js";import{l as P,s as O,p as x,r as E}from"./Dn-MmwIJ.js";import{H as D,a as w,S as f}from"./O6t-pRWL.js";import{b as I,V as K,I as N,P as y,c as A,h as U,m as V,d as k,t as S,e as C,f as h,i as z,j as F,k as $,l as B,n as H,T as m,o as L}from"./CKMI08DK.js";import{b as G}from"./CWuJKFCW.js";function d(s,t,e,r){function n(i){return i instanceof e?i:new e(function(o){o(i)})}return new(e||(e=Promise))(function(i,o){function c(a){try{u(r.next(a))}catch(p){o(p)}}function g(a){try{u(r.throw(a))}catch(p){o(p)}}function u(a){a.done?i(a.value):n(a.value).then(c,g)}u((r=r.apply(s,[])).next())})}class q extends L{constructor(t,e){super(),this.message=t,this.cause=e,this.name="OperationNotAuthorized"}}class M extends m{constructor(t,e,r){super(),this.cause=t,this.bytes=e,this.watermark=r,this.name="BadSigningData",this.message=r?"Invalid signing data with watermark":`Invalid signing data: "${e}"`}}class j extends m{constructor(t,e,r){super(),this.requestedPk=t,this.requestedPkh=e,this.initializedPkh=r,this.name="PublicKeyVerificationFailedError",this.message=`Requested pk "${t}" has pkh "${e}" deesn't match initialized pkh "${r}."`}}class Q extends m{constructor(t,e){super(),this.bytes=t,this.signature=e,this.name="SignatureVerificationFailedError",this.name="SignatureVerificationFailedError",this.message="Invalid signature of bytes failed verification agaisnt public key."}}class W{constructor(t,e,r={},n=new D){this.pkh=t,this.rootUrl=e,this.options=r,this.http=n;const i=I(this.pkh);if(i!==K.VALID)throw new N(this.pkh,i)}publicKeyHash(){return d(this,void 0,void 0,function*(){return this.pkh})}createURL(t){let e=this.rootUrl;for(;e.endsWith("/");)e=e.slice(0,-1);return`${e}${t}`}publicKey(){return d(this,void 0,void 0,function*(){try{const{public_key:t}=yield this.http.createRequest({url:this.createURL(`/keys/${this.pkh}`),method:"GET",headers:this.options.headers});return t}catch(t){throw t instanceof w&&t.status===f.NOT_FOUND?new y(this.pkh,t):t}})}secretKey(){return d(this,void 0,void 0,function*(){throw new A("Secret key cannot be exposed")})}sign(t,e){return d(this,void 0,void 0,function*(){try{let r=U(t);typeof e<"u"&&(r=V(e,r));const n=k(S(r)),{signature:i}=yield this.http.createRequest({url:this.createURL(`/keys/${this.pkh}`),method:"POST",headers:this.options.headers},n),[o]=(()=>{try{return C(i,[h.GenericSignature,h.Secp256k1Signature,h.Ed25519Signature,h.P256Signature])}catch(u){throw u instanceof z?new F(i,u.result):u}})(),c=yield this.publicKey();if(yield this.verifyPublicKey(c),!$(n,c,i))throw new Q(n,i);return{bytes:t,sig:B(o,h.GenericSignature),prefixSig:i,sbytes:t+k(S(o))}}catch(r){if(r instanceof w){if(r.status===f.NOT_FOUND)throw new y(this.pkh,r);if(r.status===f.FORBIDDEN)throw new q("Signing Operation not authorized",r);if(r.status===f.BAD_REQUEST)throw new M(r,t,e)}throw r}})}verifyPublicKey(t){return d(this,void 0,void 0,function*(){const e=H(t);if(this.pkh!==e)throw new j(t,e,this.pkh)})}}const Y=async(s,t)=>{const{createTezosToolkit:e}=await R(async()=>{const{createTezosToolkit:c}=await import("./DivCsxyi.js");return{createTezosToolkit:c}},__vite__mapDeps([0,1,2]),import.meta.url),r=await e(s.rpc),n=new W(t.pkh,t.url);r.setSignerProvider(n);const i=await r.signer.publicKeyHash();await r.signer.publicKey(),O(l,{url:t.url,pkh:t.pkh,network:x(s,["id","rpc"])});const o=i?await r.rpc.getManagerKey(i):void 0;return{accountId:i,tezos:r,isActivated:o!==void 0}},J=async()=>{const s=P(l);if(!s)return!1;const{network:t,pkh:e,url:r}=s;return{network:v(t.id,t.rpc),pkh:e,url:r}},X=3e5,Z=async(s,t)=>{try{const e=await T(s),{accountId:r,tezos:n,isActivated:i}=await Promise.race([await Y(e,t),b(X)]),o={...G,id:r,isActivated:i,type:"remote-signer",network:s.id.toString(),explorer:e.explorer,rpc:e.rpc},c=n;return c.signOperation=async a=>({signature:(await n.signer.sign(a,new Uint8Array([3]))).sbytes.slice(a.length)}),{...await _(o,s,c),logout:async()=>{E(l)}}}catch(e){throw e}};async function ct(){const s=await J();if(!s)return!1;const{network:t,pkh:e,url:r}=s;try{return await Z(t,{pkh:e,url:r})}catch{return E(l),!1}}export{Z as createRemoteSignerSession,ct as tryLoadCachedRemoteSignerSession};
