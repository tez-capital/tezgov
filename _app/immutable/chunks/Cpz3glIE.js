const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./pyTdfEmM.js","./CG0HDjPF.js","./zf1WrKjG.js"])))=>i.map(i=>d[i]);
import{g as O,R as g,c as x}from"./BpuyuJIU.js";import{c as D}from"./CLlCEFAX.js";import{t as I}from"./trIFHh5f.js";import{_ as K}from"./CG0HDjPF.js";import{l as N,s as P,p as A,r as R}from"./c1W0uvcj.js";import{H as U,a as m,S as l}from"./kawmPrN3.js";import{b as V,V as w,I as z,i as y,p as n,P as E,c as C,h as F,m as H,d as v,t as S,e as $,f as B,g as b,j as L,k as T,l as q,T as k,n as M}from"./52FGy33q.js";import{b as G}from"./DAW5omEl.js";function d(s,t,e,i){function o(r){return r instanceof e?r:new e(function(a){a(r)})}return new(e||(e=Promise))(function(r,a){function h(c){try{p(i.next(c))}catch(f){a(f)}}function u(c){try{p(i.throw(c))}catch(f){a(f)}}function p(c){c.done?r(c.value):o(c.value).then(h,u)}p((i=i.apply(s,[])).next())})}class W extends M{constructor(t,e){super(),this.message=t,this.cause=e,this.name="OperationNotAuthorized"}}class j extends k{constructor(t,e,i){super(),this.cause=t,this.bytes=e,this.watermark=i,this.name="BadSigningData",this.message=i?"Invalid signing data with watermark":`Invalid signing data: "${e}"`}}class Q extends k{constructor(t,e,i){super(),this.requestedPk=t,this.requestedPkh=e,this.initializedPkh=i,this.name="PublicKeyVerificationFailedError",this.message=`Requested pk "${t}" has pkh "${e}" deesn't match initialized pkh "${i}."`}}class X extends k{constructor(t,e){super(),this.bytes=t,this.signature=e,this.name="SignatureVerificationFailedError",this.name="SignatureVerificationFailedError",this.message="Invalid signature of bytes failed verification agaisnt public key."}}const _={ed:{pk:n.edpk,sk:n.edsk,pkh:n.tz1,sig:n.edsig},p2:{pk:n.p2pk,sk:n.p2sk,pkh:n.tz3,sig:n.p2sig},sp:{pk:n.sppk,sk:n.spsk,pkh:n.tz2,sig:n.spsig}};class Y{constructor(t,e,i={},o=new U){this.pkh=t,this.rootUrl=e,this.options=i,this.http=o;const r=V(this.pkh);if(r!==w.VALID)throw new z(this.pkh,y(r))}publicKeyHash(){return d(this,void 0,void 0,function*(){return this.pkh})}createURL(t){let e=this.rootUrl;for(;e.endsWith("/");)e=e.slice(0,-1);return`${e}${t}`}publicKey(){return d(this,void 0,void 0,function*(){try{const{public_key:t}=yield this.http.createRequest({url:this.createURL(`/keys/${this.pkh}`),method:"GET",headers:this.options.headers});return t}catch(t){throw t instanceof m&&t.status===l.NOT_FOUND?new E(this.pkh,t):t}})}secretKey(){return d(this,void 0,void 0,function*(){throw new C("Secret key cannot be exposed")})}sign(t,e){return d(this,void 0,void 0,function*(){try{let i=F(t);typeof e<"u"&&(i=H(e,i));const o=v(S(i)),{signature:r}=yield this.http.createRequest({url:this.createURL(`/keys/${this.pkh}`),method:"POST",headers:this.options.headers},o),a=r.startsWith("sig")?r.substring(0,3):r.substring(0,5);if(!$(a))throw new B(r,y(w.NO_PREFIX_MATCHED)+" from a remote signer.");const h=b(r,n[a]),u=yield this.publicKey();if(yield this.verifyPublicKey(u),!L(o,u,r))throw new X(o,r);return{bytes:t,sig:T(h,n.sig),prefixSig:r,sbytes:t+v(S(h))}}catch(i){if(i instanceof m){if(i.status===l.NOT_FOUND)throw new E(this.pkh,i);if(i.status===l.FORBIDDEN)throw new W("Signing Operation not authorized",i);if(i.status===l.BAD_REQUEST)throw new j(i,t,e)}throw i}})}verifyPublicKey(t){return d(this,void 0,void 0,function*(){const e=t.substring(0,2),i=b(t,_[e].pk),o=T(q.hash(i,20),_[e].pkh);if(o!==this.pkh)throw new Q(t,o,this.pkh)})}}const J=async(s,t)=>{const{createTezosToolkit:e}=await K(async()=>{const{createTezosToolkit:h}=await import("./pyTdfEmM.js");return{createTezosToolkit:h}},__vite__mapDeps([0,1,2]),import.meta.url),i=await e(s.rpc),o=new Y(t.pkh,t.url);i.setSignerProvider(o);const r=await i.signer.publicKeyHash();await i.signer.publicKey(),P(g,{url:t.url,pkh:t.pkh,network:A(s,["id","rpc"])});const a=r?await i.rpc.getManagerKey(r):void 0;return{accountId:r,tezos:i,isActivated:a!==void 0}},Z=async()=>{const s=N(g);if(!s)return!1;const{network:t,pkh:e,url:i}=s;return{network:O(t.id,t.rpc),pkh:e,url:i}},tt=3e5,et=async(s,t)=>{try{const e=await x(s),{accountId:i,tezos:o,isActivated:r}=await Promise.race([await J(e,t),I(tt)]),a={...G,id:i,isActivated:r,type:"remote-signer",network:s.id.toString(),explorer:e.explorer,rpc:e.rpc},h=o;return h.signOperation=async c=>({signature:(await o.signer.sign(c,new Uint8Array([3]))).sbytes.slice(c.length)}),{...await D(a,s,h),logout:async()=>{R(g)}}}catch(e){throw e}};async function ut(){const s=await Z();if(!s)return!1;const{network:t,pkh:e,url:i}=s;try{return await et(t,{pkh:e,url:i})}catch{return R(g),!1}}export{et as createRemoteSignerSession,ut as tryLoadCachedRemoteSignerSession};
