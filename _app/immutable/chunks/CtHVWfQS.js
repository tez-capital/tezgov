var Qe=Object.defineProperty;var Je=(n,s,e)=>s in n?Qe(n,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[s]=e;var l=(n,s,e)=>Je(n,typeof s!="symbol"?s+"":s,e);import Ce from"./B0yp3bM1.js";import{E as A,w as G,S as p,a as ne,b as Re,g as ie,c as W,e as Ye,B as w,P as N,d as be,T as P,f as Q,h as O,L as U,i as $,j as Ie,k as Xe,l as Le,O as R,N as v,m as ke,W as pe,n as F,o as fe,I as Ze,p as et,v as we,C as tt,q as y,r as C,s as st,y as nt,x as it,u as at,D as rt,V as ot,z as ct,Q as lt,A as b,F as K,G as dt,H as ut,J as ht,K as pt,M as ft,R as me,U as wt,X as mt,Y as gt,Z as yt,_ as ge,$ as ye,a0 as vt}from"./BmY7r1WI.js";import{b as Se}from"./B3Toc7tj.js";import{p as Et,o as Me,h as At,m as Tt,d as Pt,t as _t,U as Ct}from"./CKMI08DK.js";import{c as j,b as Rt,d as bt,e as It,f as Lt}from"./O6t-pRWL.js";import{i as ve}from"./Ch_IHUOo.js";import{U as kt}from"./BUnv9UM3.js";class St{track(s,e,t,i){}}class Mt{constructor(s){l(this,"name");l(this,"iconUrl");l(this,"appUrl");l(this,"_beaconId",new A);l(this,"storage");l(this,"analytics");l(this,"_keyPair",new A);if(!s.name)throw new Error("Name not set");if(!s.storage)throw new Error("Storage not set");this.name=s.name,this.iconUrl=s.iconUrl,this.appUrl=s.appUrl??G.location.origin,this.storage=s.storage,this.analytics=s.analytics??new St,G.beaconCreatedClientInstance?console.error("[BEACON] It looks like you created multiple Beacon SDK Client instances. This can lead to problems. Only create one instance and re-use it everywhere."):G.beaconCreatedClientInstance=!0,this.initSDK().catch(console.error)}get beaconId(){return this._beaconId.promise}get keyPair(){return this._keyPair.promise}async destroy(){await this.removeBeaconEntriesFromStorage(),G.beaconCreatedClientInstance=!1}async initSDK(){return this.storage.set(p.BEACON_SDK_VERSION,ne).catch(console.error),this.loadOrCreateBeaconSecret().catch(console.error),this.keyPair.then(s=>{this._beaconId.resolve(Re(s.publicKey))})}async removeBeaconEntriesFromStorage(){const s=Object.values(p);await Promise.all(s.map(e=>this.storage.delete(e)))}async loadOrCreateBeaconSecret(){const s=await this.storage.get(p.BEACON_SDK_SECRET_SEED);if(s&&typeof s=="string")this._keyPair.resolve(await ie(s));else{const e=await W();await this.storage.set(p.BEACON_SDK_SECRET_SEED,e),this._keyPair.resolve(await ie(e))}}}const ae=async(n,s)=>{const e=[n,s.type];s.name&&e.push(`name:${s.name}`),s.rpcUrl&&e.push(`rpc:${s.rpcUrl}`);const t=Buffer.from(Et.hash(Ye(e.join("-")),10));return Se.encode(t)};class Nt{static async hasPermission(s,e,t){switch(s.type){case w.PermissionRequest:case w.BroadcastRequest:return!0;case w.OperationRequest:{const i=await ae(s.sourceAddress,s.network),a=await e(i);return a?a.scopes.includes(N.OPERATION_REQUEST):!1}case w.SignPayloadRequest:{const a=(await t()).filter(r=>r.address===s.sourceAddress);return a.length===0?!1:a.some(r=>r.scopes.includes(N.SIGN))}default:throw new Error("Message not handled")}}}class Ot{constructor(s){l(this,"storageManager");this.storageManager=new be(s,p.ACCOUNTS)}async getAccounts(){return await this.storageManager.getAll()??[]}async getAccount(s){return this.storageManager.getOne(e=>e.accountIdentifier===s)}async addAccount(s){return this.storageManager.addOne(s,e=>e.accountIdentifier===s.accountIdentifier)}async updateAccount(s,e){const t=await this.getAccount(s);if(!t)return;const i={...t,...e};return await this.storageManager.addOne(i,a=>a.accountIdentifier===s,!0),i}async removeAccount(s){return this.storageManager.remove(e=>e.accountIdentifier===s)}async removeAccounts(s){return this.storageManager.remove(e=>s.includes(e.accountIdentifier))}async removeAllAccounts(){return this.storageManager.removeAll()}async hasPermission(s){return Nt.hasPermission(s,this.getAccount.bind(this),this.getAccounts.bind(this))}}const Dt=new U("Client");class qt extends Mt{constructor(e){super(e);l(this,"accountManager");l(this,"handleResponse");l(this,"rateLimit",2);l(this,"rateLimitWindowInSeconds",5);l(this,"requestCounter",[]);l(this,"matrixNodes");l(this,"transportListeners",new Map);l(this,"_transport",new A);this.accountManager=new Ot(e.storage),this.matrixNodes=e.matrixNodes??{},this.handleResponse=(t,i)=>{throw new Error(`not overwritten${JSON.stringify(t)} - ${JSON.stringify(i)}`)}}get transport(){return this._transport.promise}get connectionStatus(){return this._transport.promiseResult?.connectionStatus??P.NOT_CONNECTED}get ready(){return this.transport.then(()=>{})}async cleanup(){if(this.transportListeners.size&&this._transport.isResolved()){const e=await this.transport;await Promise.all(Array.from(this.transportListeners.values()).map(t=>e.removeListener(t))),this.transportListeners.clear()}}async getAccounts(){return this.accountManager.getAccounts()}async getAccount(e){return this.accountManager.getAccount(e)}async removeAccount(e){return this.accountManager.removeAccount(e)}async removeAllAccounts(){return this.accountManager.removeAllAccounts()}async addRequestAndCheckIfRateLimited(){const e=new Date().getTime();return this.requestCounter=this.requestCounter.filter(t=>t+this.rateLimitWindowInSeconds*1e3>e),this.requestCounter.push(e),this.requestCounter.length>this.rateLimit}async init(e){return this._transport.isResolved()?(await this.transport).type:(await this.setTransport(e),e.type)}async getOwnAppMetadata(){return{senderId:await Q(await this.beaconId),name:this.name,icon:this.iconUrl}}async getPeers(){return(await this.transport).getPeers()}async addPeer(e){return(await this.transport).addPeer(e)}async destroy(){if(this._transport.isResolved()){const e=await this.transport;await this.cleanup(),await e.disconnect(),e.type===O.WALLETCONNECT&&await e.doClientCleanup()}await super.destroy()}async setTransport(e){e?this._transport.isSettled()?this._transport=A.resolve(e):this._transport.resolve(e):this._transport.isSettled()&&(this._transport=new A)}async addListener(e){this.transportListeners.has(e.type)&&await e.removeListener(this.transportListeners.get(e.type));const t=async(i,a)=>{if(typeof i=="string"){const r=await new $().deserialize(i);this.handleResponse(r,a)}};this.transportListeners.set(e.type,t),e.addListener(t).catch(i=>Dt.error("addListener",i))}async sendDisconnectToPeer(e,t){const i={id:await W(),version:e.version,senderId:await Q(await this.beaconId),type:w.Disconnect},a=await new $().serialize(i);await(t??await this.transport).send(a,e)}}class Bt{constructor(s){l(this,"storageManager");this.storageManager=new be(s,p.APP_METADATA_LIST)}async getAppMetadataList(){return await this.storageManager.getAll()??[]}async getAppMetadata(s){return this.storageManager.getOne(e=>e.senderId===s)}async addAppMetadata(s){return this.storageManager.addOne(s,e=>e.senderId===s.senderId)}async removeAppMetadata(s){return this.storageManager.remove(e=>e.senderId===s)}async removeAppMetadatas(s){return this.storageManager.remove(e=>s.includes(e.senderId))}async removeAllAppMetadata(){return this.storageManager.removeAll()}}class xt{constructor(s){l(this,"storage");this.storage=s}validateNumber(s){return typeof s=="number"&&!isNaN(s)}validateText(s){return typeof s=="string"}validateBoolean(s){return typeof s=="boolean"}validateArray(s){return Array.isArray(s)}objHasProperty(s,e){if(!s)return!1;const t=e.split(".");let i=s;for(const a of t){if(!i.hasOwnProperty(a))return!1;i=i[a]}return!0}innerValidate(s,e,t){if(!s)return!0;switch(e){case"num":return this.validateNumber(s);case"str":return this.validateText(s);case"bol":return this.validateBoolean(s);case"obj":return this.objHasProperty(s,t);case"arr":return this.validateArray(s);default:return!1}}async validate(){return!(!this.innerValidate(await this.storage.get(p.BEACON_SDK_VERSION),"str")||!this.innerValidate(await this.storage.get(p.MATRIX_SELECTED_NODE),"str")||!this.innerValidate(await this.storage.get(p.MULTI_NODE_SETUP_DONE),"bol")||!this.innerValidate(await this.storage.get(p.TRANSPORT_P2P_PEERS_DAPP),"arr")||!this.innerValidate(await this.storage.get(p.TRANSPORT_P2P_PEERS_WALLET),"arr")||!this.innerValidate(await this.storage.get(p.TRANSPORT_POSTMESSAGE_PEERS_DAPP),"arr")||!this.innerValidate(await this.storage.get(p.TRANSPORT_POSTMESSAGE_PEERS_WALLET),"arr")||!this.innerValidate(await this.storage.get(p.TRANSPORT_WALLETCONNECT_PEERS_DAPP),"arr")||!this.innerValidate(await this.storage.get(p.ACCOUNTS),"arr")||!this.innerValidate(await this.storage.get(p.APP_METADATA_LIST),"arr")||!this.innerValidate(await this.storage.get(p.PERMISSION_LIST),"arr")||!this.innerValidate(await this.storage.get(p.ACTIVE_ACCOUNT),"str")||!this.innerValidate(await this.storage.get(p.LAST_SELECTED_WALLET),"obj","key"))}}function Wt(n){return n&&typeof n.then=="function"}Promise.resolve(!1);var Ut=Promise.resolve(!0),k=Promise.resolve();function B(n,s){return n||(n=0),new Promise(function(e){return setTimeout(function(){return e(s)},n)})}function Kt(n,s){return Math.floor(Math.random()*(s-n+1)+n)}function H(){return Math.random().toString(36).substring(2)}var X=0;function z(){var n=Date.now()*1e3;return n<=X&&(n=X+1),X=n,n}function Ft(){return typeof navigator<"u"&&typeof navigator.locks<"u"&&typeof navigator.locks.request=="function"}var $t=z,Vt="native";function Ht(n){var s={time:z(),messagesCallback:null,bc:new BroadcastChannel(n),subFns:[]};return s.bc.onmessage=function(e){s.messagesCallback&&s.messagesCallback(e.data)},s}function zt(n){n.bc.close(),n.subFns=[]}function Gt(n,s){try{return n.bc.postMessage(s,!1),k}catch(e){return Promise.reject(e)}}function jt(n,s){n.messagesCallback=s}function Qt(){if(typeof globalThis<"u"&&globalThis.Deno&&globalThis.Deno.args)return!0;if((typeof window<"u"||typeof self<"u")&&typeof BroadcastChannel=="function"){if(BroadcastChannel._pubkey)throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");return!0}else return!1}function Jt(){return 150}var Yt={create:Ht,close:zt,onMessage:jt,postMessage:Gt,canBeUsed:Qt,type:Vt,averageResponseTime:Jt,microSeconds:$t};class Ne{constructor(s){l(this,"ttl");l(this,"map",new Map);l(this,"_to",!1);this.ttl=s}has(s){return this.map.has(s)}add(s){this.map.set(s,Oe()),this._to||(this._to=!0,setTimeout(()=>{this._to=!1,Xt(this)},0))}clear(){this.map.clear()}}function Xt(n){const s=Oe()-n.ttl,e=n.map[Symbol.iterator]();for(;;){const t=e.next().value;if(!t)return;const i=t[0];if(t[1]<s)n.map.delete(i);else return}}function Oe(){return Date.now()}function oe(){var n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},s=JSON.parse(JSON.stringify(n));return typeof s.webWorkerSupport>"u"&&(s.webWorkerSupport=!0),s.idb||(s.idb={}),s.idb.ttl||(s.idb.ttl=1e3*45),s.idb.fallbackInterval||(s.idb.fallbackInterval=150),n.idb&&typeof n.idb.onclose=="function"&&(s.idb.onclose=n.idb.onclose),s.localstorage||(s.localstorage={}),s.localstorage.removeTimeout||(s.localstorage.removeTimeout=1e3*60),n.methods&&(s.methods=n.methods),s.node||(s.node={}),s.node.ttl||(s.node.ttl=1e3*60*2),s.node.maxParallelWrites||(s.node.maxParallelWrites=2048),typeof s.node.useFastPath>"u"&&(s.node.useFastPath=!0),s}var Zt=z,es="pubkey.broadcast-channel-0-",S="messages",J={durability:"relaxed"},ts="idb";function De(){if(typeof indexedDB<"u")return indexedDB;if(typeof window<"u"){if(typeof window.mozIndexedDB<"u")return window.mozIndexedDB;if(typeof window.webkitIndexedDB<"u")return window.webkitIndexedDB;if(typeof window.msIndexedDB<"u")return window.msIndexedDB}return!1}function ce(n){n.commit&&n.commit()}function ss(n){var s=De(),e=es+n,t=s.open(e);return t.onupgradeneeded=function(i){var a=i.target.result;a.createObjectStore(S,{keyPath:"id",autoIncrement:!0})},new Promise(function(i,a){t.onerror=function(r){return a(r)},t.onsuccess=function(){i(t.result)}})}function ns(n,s,e){var t=Date.now(),i={uuid:s,time:t,data:e},a=n.transaction([S],"readwrite",J);return new Promise(function(r,o){a.oncomplete=function(){return r()},a.onerror=function(u){return o(u)};var c=a.objectStore(S);c.add(i),ce(a)})}function is(n,s){var e=n.transaction(S,"readonly",J),t=e.objectStore(S),i=[],a=IDBKeyRange.bound(s+1,1/0);if(t.getAll){var r=t.getAll(a);return new Promise(function(c,u){r.onerror=function(h){return u(h)},r.onsuccess=function(h){c(h.target.result)}})}function o(){try{return a=IDBKeyRange.bound(s+1,1/0),t.openCursor(a)}catch{return t.openCursor()}}return new Promise(function(c,u){var h=o();h.onerror=function(f){return u(f)},h.onsuccess=function(f){var g=f.target.result;g?g.value.id<s+1?g.continue(s+1):(i.push(g.value),g.continue()):(ce(e),c(i))}})}function as(n,s){if(n.closed)return Promise.resolve([]);var e=n.db.transaction(S,"readwrite",J),t=e.objectStore(S);return Promise.all(s.map(function(i){var a=t.delete(i);return new Promise(function(r){a.onsuccess=function(){return r()}})}))}function rs(n,s){var e=Date.now()-s,t=n.transaction(S,"readonly",J),i=t.objectStore(S),a=[];return new Promise(function(r){i.openCursor().onsuccess=function(o){var c=o.target.result;if(c){var u=c.value;u.time<e?(a.push(u),c.continue()):(ce(t),r(a))}else r(a)}})}function os(n){return rs(n.db,n.options.idb.ttl).then(function(s){return as(n,s.map(function(e){return e.id}))})}function cs(n,s){return s=oe(s),ss(n).then(function(e){var t={closed:!1,lastCursorId:0,channelName:n,options:s,uuid:H(),eMIs:new Ne(s.idb.ttl*2),writeBlockPromise:k,messagesCallback:null,readQueuePromises:[],db:e};return e.onclose=function(){t.closed=!0,s.idb.onclose&&s.idb.onclose()},qe(t),t})}function qe(n){n.closed||Be(n).then(function(){return B(n.options.idb.fallbackInterval)}).then(function(){return qe(n)})}function ls(n,s){return!(n.uuid===s.uuid||s.eMIs.has(n.id)||n.data.time<s.messagesCallbackTime)}function Be(n){return n.closed||!n.messagesCallback?k:is(n.db,n.lastCursorId).then(function(s){var e=s.filter(function(t){return!!t}).map(function(t){return t.id>n.lastCursorId&&(n.lastCursorId=t.id),t}).filter(function(t){return ls(t,n)}).sort(function(t,i){return t.time-i.time});return e.forEach(function(t){n.messagesCallback&&(n.eMIs.add(t.id),n.messagesCallback(t.data))}),k})}function ds(n){n.closed=!0,n.db.close()}function us(n,s){return n.writeBlockPromise=n.writeBlockPromise.then(function(){return ns(n.db,n.uuid,s)}).then(function(){Kt(0,10)===0&&os(n)}),n.writeBlockPromise}function hs(n,s,e){n.messagesCallbackTime=e,n.messagesCallback=s,Be(n)}function ps(){return!!De()}function fs(n){return n.idb.fallbackInterval*2}var ws={create:cs,close:ds,onMessage:hs,postMessage:us,canBeUsed:ps,type:ts,averageResponseTime:fs,microSeconds:Zt},ms=z,gs="pubkey.broadcastChannel-",ys="localstorage";function xe(){var n;if(typeof window>"u")return null;try{n=window.localStorage,n=window["ie8-eventlistener/storage"]||window.localStorage}catch{}return n}function We(n){return gs+n}function vs(n,s){return new Promise(function(e){B().then(function(){var t=We(n.channelName),i={token:H(),time:Date.now(),data:s,uuid:n.uuid},a=JSON.stringify(i);xe().setItem(t,a);var r=document.createEvent("Event");r.initEvent("storage",!0,!0),r.key=t,r.newValue=a,window.dispatchEvent(r),e()})})}function Es(n,s){var e=We(n),t=function(a){a.key===e&&s(JSON.parse(a.newValue))};return window.addEventListener("storage",t),t}function As(n){window.removeEventListener("storage",n)}function Ts(n,s){if(s=oe(s),!Ue())throw new Error("BroadcastChannel: localstorage cannot be used");var e=H(),t=new Ne(s.localstorage.removeTimeout),i={channelName:n,uuid:e,eMIs:t};return i.listener=Es(n,function(a){i.messagesCallback&&a.uuid!==e&&(!a.token||t.has(a.token)||a.data.time&&a.data.time<i.messagesCallbackTime||(t.add(a.token),i.messagesCallback(a.data)))}),i}function Ps(n){As(n.listener)}function _s(n,s,e){n.messagesCallbackTime=e,n.messagesCallback=s}function Ue(){var n=xe();if(!n)return!1;try{var s="__broadcastchannel_check";n.setItem(s,"works"),n.removeItem(s)}catch{return!1}return!0}function Cs(){var n=120,s=navigator.userAgent.toLowerCase();return s.includes("safari")&&!s.includes("chrome")?n*2:n}var Rs={create:Ts,close:Ps,onMessage:_s,postMessage:vs,canBeUsed:Ue,type:ys,averageResponseTime:Cs,microSeconds:ms},Ke=z,bs="simulate",le=new Set;function Is(n){var s={time:Ke(),name:n,messagesCallback:null};return le.add(s),s}function Ls(n){le.delete(n)}var Fe=5;function ks(n,s){return new Promise(function(e){return setTimeout(function(){var t=Array.from(le);t.forEach(function(i){i.name===n.name&&i!==n&&i.messagesCallback&&i.time<s.time&&i.messagesCallback(s)}),e()},Fe)})}function Ss(n,s){n.messagesCallback=s}function Ms(){return!0}function Ns(){return Fe}var Os={create:Is,close:Ls,onMessage:Ss,postMessage:ks,canBeUsed:Ms,type:bs,averageResponseTime:Ns,microSeconds:Ke},Ee=[Yt,ws,Rs];function Ds(n){var s=[].concat(n.methods,Ee).filter(Boolean);if(n.type){if(n.type==="simulate")return Os;var e=s.find(function(i){return i.type===n.type});if(e)return e;throw new Error("method-type "+n.type+" not found")}n.webWorkerSupport||(s=s.filter(function(i){return i.type!=="idb"}));var t=s.find(function(i){return i.canBeUsed()});if(t)return t;throw new Error("No usable method found in "+JSON.stringify(Ee.map(function(i){return i.type})))}var $e=new Set,qs=0,de=function(s,e){this.id=qs++,$e.add(this),this.name=s,this.options=oe(e),this.method=Ds(this.options),this._iL=!1,this._onML=null,this._addEL={message:[],internal:[]},this._uMP=new Set,this._befC=[],this._prepP=null,Bs(this)};de._pubkey=!0;de.prototype={postMessage:function(s){if(this.closed)throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed "+JSON.stringify(s));return Ae(this,"message",s)},postInternal:function(s){return Ae(this,"internal",s)},set onmessage(n){var s=this.method.microSeconds(),e={time:s,fn:n};Pe(this,"message",this._onML),n&&typeof n=="function"?(this._onML=e,Te(this,"message",e)):this._onML=null},addEventListener:function(s,e){var t=this.method.microSeconds(),i={time:t,fn:e};Te(this,s,i)},removeEventListener:function(s,e){var t=this._addEL[s].find(function(i){return i.fn===e});Pe(this,s,t)},close:function(){var s=this;if(!this.closed){$e.delete(this),this.closed=!0;var e=this._prepP?this._prepP:k;return this._onML=null,this._addEL.message=[],e.then(function(){return Promise.all(Array.from(s._uMP))}).then(function(){return Promise.all(s._befC.map(function(t){return t()}))}).then(function(){return s.method.close(s._state)})}},get type(){return this.method.type},get isClosed(){return this.closed}};function Ae(n,s,e){var t=n.method.microSeconds(),i={time:t,type:s,data:e},a=n._prepP?n._prepP:k;return a.then(function(){var r=n.method.postMessage(n._state,i);return n._uMP.add(r),r.catch().then(function(){return n._uMP.delete(r)}),r})}function Bs(n){var s=n.method.create(n.name,n.options);Wt(s)?(n._prepP=s,s.then(function(e){n._state=e})):n._state=s}function Ve(n){return n._addEL.message.length>0||n._addEL.internal.length>0}function Te(n,s,e){n._addEL[s].push(e),xs(n)}function Pe(n,s,e){n._addEL[s]=n._addEL[s].filter(function(t){return t!==e}),Ws(n)}function xs(n){if(!n._iL&&Ve(n)){var s=function(i){n._addEL[i.type].forEach(function(a){i.time>=a.time&&a.fn(i.data)})},e=n.method.microSeconds();n._prepP?n._prepP.then(function(){n._iL=!0,n.method.onMessage(n._state,s,e)}):(n._iL=!0,n.method.onMessage(n._state,s,e))}}function Ws(n){if(n._iL&&!Ve(n)){n._iL=!1;var s=n.method.microSeconds();n.method.onMessage(n._state,null,s)}}function Us(n){if(typeof WorkerGlobalScope=="function"&&self instanceof WorkerGlobalScope){var s=self.close.bind(self);self.close=function(){return n(),s()}}else{if(typeof window.addEventListener!="function")return;window.addEventListener("beforeunload",function(){n()},!0),window.addEventListener("unload",function(){n()},!0)}}function Ks(n){process.on("exit",function(){return n()}),process.on("beforeExit",function(){return n().then(function(){return process.exit()})}),process.on("SIGINT",function(){return n().then(function(){return process.exit()})}),process.on("uncaughtException",function(s){return n().then(function(){console.trace(s),process.exit(101)})})}var Fs=Object.prototype.toString.call(typeof process<"u"?process:0)==="[object process]",$s=Fs?Ks:Us,V=new Set,_e=!1;function Vs(){_e||(_e=!0,$s(zs))}function Hs(n){if(Vs(),typeof n!="function")throw new Error("Listener is no function");V.add(n);var s={remove:function(){return V.delete(n)},run:function(){return V.delete(n),n()}};return s}function zs(){var n=[];return V.forEach(function(s){n.push(s()),V.delete(s)}),Promise.all(n)}function x(n,s){var e={context:"leader",action:s,token:n.token};return n.broadcastChannel.postInternal(e)}function He(n){n.isLeader=!0,n._hasLeader=!0;var s=Hs(function(){return n.die()});n._unl.push(s);var e=function(i){i.context==="leader"&&i.action==="apply"&&x(n,"tell"),i.context==="leader"&&i.action==="tell"&&!n._dpLC&&(n._dpLC=!0,n._dpL(),x(n,"tell"))};return n.broadcastChannel.addEventListener("internal",e),n._lstns.push(e),x(n,"tell")}var ze=function(s,e){var t=this;this.broadcastChannel=s,s._befC.push(function(){return t.die()}),this._options=e,this.isLeader=!1,this.isDead=!1,this.token=H(),this._lstns=[],this._unl=[],this._dpL=function(){},this._dpLC=!1,this._wKMC={},this.lN="pubkey-bc||"+s.method.type+"||"+s.name};ze.prototype={hasLeader:function(){var s=this;return navigator.locks.query().then(function(e){var t=e.held?e.held.filter(function(i){return i.name===s.lN}):[];return!!(t&&t.length>0)})},awaitLeadership:function(){var s=this;if(!this._wLMP){this._wKMC.c=new AbortController;var e=new Promise(function(t,i){s._wKMC.res=t,s._wKMC.rej=i});this._wLMP=new Promise(function(t){navigator.locks.request(s.lN,{signal:s._wKMC.c.signal},function(){return s._wKMC.c=void 0,He(s),t(),e}).catch(function(){})})}return this._wLMP},set onduplicate(n){},die:function(){var s=this;return this._lstns.forEach(function(e){return s.broadcastChannel.removeEventListener("internal",e)}),this._lstns=[],this._unl.forEach(function(e){return e.remove()}),this._unl=[],this.isLeader&&(this.isLeader=!1),this.isDead=!0,this._wKMC.res&&this._wKMC.res(),this._wKMC.c&&this._wKMC.c.abort("LeaderElectionWebLock.die() called"),x(this,"death")}};var Ge=function(s,e){var t=this;this.broadcastChannel=s,this._options=e,this.isLeader=!1,this._hasLeader=!1,this.isDead=!1,this.token=H(),this._aplQ=k,this._aplQC=0,this._unl=[],this._lstns=[],this._dpL=function(){},this._dpLC=!1;var i=function(r){r.context==="leader"&&(r.action==="death"&&(t._hasLeader=!1),r.action==="tell"&&(t._hasLeader=!0))};this.broadcastChannel.addEventListener("internal",i),this._lstns.push(i)};Ge.prototype={hasLeader:function(){return Promise.resolve(this._hasLeader)},applyOnce:function(s){var e=this;if(this.isLeader)return B(0,!0);if(this.isDead)return B(0,!1);if(this._aplQC>1)return this._aplQ;var t=function(){if(e.isLeader)return Ut;var a=!1,r,o=new Promise(function(h){r=function(){a=!0,h()}}),c=function(f){f.context==="leader"&&f.token!=e.token&&(f.action==="apply"&&f.token>e.token&&r(),f.action==="tell"&&(r(),e._hasLeader=!0))};e.broadcastChannel.addEventListener("internal",c);var u=s?e._options.responseTime*4:e._options.responseTime;return x(e,"apply").then(function(){return Promise.race([B(u),o.then(function(){return Promise.reject(new Error)})])}).then(function(){return x(e,"apply")}).then(function(){return Promise.race([B(u),o.then(function(){return Promise.reject(new Error)})])}).catch(function(){}).then(function(){return e.broadcastChannel.removeEventListener("internal",c),a?!1:He(e).then(function(){return!0})})};return this._aplQC=this._aplQC+1,this._aplQ=this._aplQ.then(function(){return t()}).then(function(){e._aplQC=e._aplQC-1}),this._aplQ.then(function(){return e.isLeader})},awaitLeadership:function(){return this._aLP||(this._aLP=Gs(this)),this._aLP},set onduplicate(n){this._dpL=n},die:function(){var s=this;return this._lstns.forEach(function(e){return s.broadcastChannel.removeEventListener("internal",e)}),this._lstns=[],this._unl.forEach(function(e){return e.remove()}),this._unl=[],this.isLeader&&(this._hasLeader=!1,this.isLeader=!1),this.isDead=!0,x(this,"death")}};function Gs(n){return n.isLeader?k:new Promise(function(s){var e=!1;function t(){e||(e=!0,n.broadcastChannel.removeEventListener("internal",a),s(!0))}n.applyOnce().then(function(){n.isLeader&&t()});var i=function(){return B(n._options.fallbackInterval).then(function(){if(!(n.isDead||e))if(n.isLeader)t();else return n.applyOnce(!0).then(function(){n.isLeader?t():i()})})};i();var a=function(o){o.context==="leader"&&o.action==="death"&&(n._hasLeader=!1,n.applyOnce().then(function(){n.isLeader&&t()}))};n.broadcastChannel.addEventListener("internal",a),n._lstns.push(a)})}function js(n,s){return n||(n={}),n=JSON.parse(JSON.stringify(n)),n.fallbackInterval||(n.fallbackInterval=3e3),n.responseTime||(n.responseTime=s.method.averageResponseTime(s.options)),n}function Qs(n,s){if(n._leaderElector)throw new Error("BroadcastChannel already has a leader-elector");s=js(s,n);var e=Ft()?new ze(n,s):new Ge(n,s);return n._befC.push(function(){return e.die()}),n._leaderElector=e,e}class Js{constructor(s,e,t){l(this,"channel");l(this,"elector");l(this,"eventListeners",[()=>this.onBeforeUnloadHandler(),s=>this.onMessageHandler(s)]);l(this,"onBCMessageHandler");l(this,"onElectedLeaderHandler");l(this,"wasLeader",!1);l(this,"initialized",!1);this.onBCMessageHandler=e,this.onElectedLeaderHandler=t,this.channel=new de(s),this.elector=Qs(this.channel)}async init(){if(this.initialized)return;await this.elector.hasLeader()||(await this.elector.awaitLeadership(),this.wasLeader=this.isLeader()),this.channel.onmessage=this.eventListeners[1],window?.addEventListener("beforeunload",this.eventListeners[0]),this.initialized=!0}async onBeforeUnloadHandler(){this.wasLeader&&(await this.elector.die(),this.postMessage({type:"LEADER_DEAD"})),window?.removeEventListener("beforeunload",this.eventListeners[0]),this.channel.removeEventListener("message",this.eventListeners[1])}async onMessageHandler(s){if(s.type==="LEADER_DEAD"){await this.elector.awaitLeadership(),this.wasLeader=this.isLeader(),this.isLeader()&&this.onElectedLeaderHandler();return}this.onBCMessageHandler(s)}isLeader(){return this.elector.isLeader}async getLeadership(){return this.elector.awaitLeadership()}async hasLeader(){return this.elector.hasLeader()}postMessage(s){this.channel.postMessage(s)}}const Z=new U("P2PTransport");class Ys extends Ie{constructor(e,t,i,a,r,o,c){super(e,new Xe(e,t,1,i,a,o,c),new Le(i,r));l(this,"type",O.P2P)}static async isAvailable(){return Promise.resolve(!0)}async connect(){if(this._isConnected!==P.NOT_CONNECTED)return;Z.log("connect"),this._isConnected=P.CONNECTING,await this.client.start();const e=await this.getPeers();if(e.length>0){Z.log("connect",`connecting to ${e.length} peers`);const t=e.map(async i=>this.listen(i.publicKey));Promise.all(t).catch(i=>Z.error("connect",i))}return await this.startOpenChannelListener(),super.connect()}async disconnect(){return await this.client.stop(),super.disconnect()}async startOpenChannelListener(){}async getPairingRequestInfo(){return this.client.getPairingRequestInfo()}async listen(e){await this.client.listenForEncryptedMessage(e,t=>{const i={origin:R.P2P,id:e};this.notifyListeners(t,i).catch(a=>{throw a})}).catch(t=>{throw t})}}class Xs{constructor(s){l(this,"rpcUrls");this.rpcUrls=s}async getLinkForNetwork(s){return this.rpcUrls[s.type]}}class Zs extends Xs{constructor(e={[v.MAINNET]:"https://tzkt.io",[v.GHOSTNET]:"https://ghostnet.tzkt.io",[v.WEEKLYNET]:"https://weeklynet.tzkt.io",[v.DAILYNET]:"https://dailynet.tzkt.io",[v.DELPHINET]:"https://delphinet.tzkt.io",[v.EDONET]:"https://edonet.tzkt.io",[v.FLORENCENET]:"https://florencenet.tzkt.io",[v.GRANADANET]:"https://granadanet.tzkt.io",[v.HANGZHOUNET]:"https://hangzhounet.tzkt.io",[v.ITHACANET]:"https://ithacanet.tzkt.io",[v.JAKARTANET]:"https://jakartanet.tzkt.io",[v.KATHMANDUNET]:"https://kathmandunet.tzkt.io",[v.LIMANET]:"https://limanet.tzkt.io",[v.MUMBAINET]:"https://mumbainet.tzkt.io",[v.NAIROBINET]:"https://nairobinet.tzkt.io",[v.OXFORDNET]:"https://oxfordnet.tzkt.io",[v.PARISNET]:"https://parisnet.tzkt.io",[v.CUSTOM]:"https://seoulnet.tzkt.io",[v.QUEBECNET]:"https://quebecnet.tzkt.io",[v.RIONET]:"https://rionet.tzkt.io",[v.SEOULNET]:"https://seoulnet.tzkt.io",[v.SHADOWNET]:"https://shadownet.tzkt.io"}){super(e);l(this,"rpcUrls");this.rpcUrls=e}async getAddressLink(e,t){return`${await this.getLinkForNetwork(t)}/${e}`}async getTransactionLink(e,t){return`${await this.getLinkForNetwork(t)}/${e}`}}const ee=new U("DappPostMessageTransport");class en extends ke{constructor(s,e,t){super(s,e,t,p.TRANSPORT_POSTMESSAGE_PEERS_DAPP)}async startOpenChannelListener(){return this.client.listenForChannelOpening(async s=>{ee.log("connect","received PostMessagePairingResponse",s),await this.addPeer(s),this._isConnected=P.CONNECTED,this.newPeerListener&&(this.newPeerListener(s),this.newPeerListener=void 0)})}async listenForNewPeer(s){ee.log("listenForNewPeer"),this.newPeerListener=s}async stopListeningForNewPeers(){ee.log("stopListeningForNewPeers"),this.newPeerListener=void 0}}const te=new U("DappP2PTransport");class tn extends Ys{constructor(s,e,t,i,a,r){super(s,e,t,i,p.TRANSPORT_P2P_PEERS_DAPP,a,r)}async startOpenChannelListener(){return this.client.listenForChannelOpening(async s=>{te.log("listenForNewPeer","new publicKey",s.publicKey),await this.addPeer(s),this._isConnected=P.CONNECTED,this.newPeerListener&&(this.newPeerListener(s),this.newPeerListener=void 0)})}async listenForNewPeer(s){te.log("listenForNewPeer"),this.newPeerListener=s}async stopListeningForNewPeers(){te.log("stopListeningForNewPeers"),this.newPeerListener=void 0}}class q extends Ie{constructor(e,t,i,a,r,o){super(e,pe.getInstance(r,o),new Le(i,a));l(this,"wcOptions");l(this,"isLeader");l(this,"type",O.WALLETCONNECT);l(this,"isReady",new A);this.wcOptions=r,this.isLeader=o}static async isAvailable(){return Promise.resolve(!0)}waitForResolution(){return this.isReady.promise}async connect(){if([P.CONNECTED,P.CONNECTING].includes(this._isConnected))return;this._isConnected=P.CONNECTING;const e=await this.isLeader();e&&await this.client.init();const t=await this.getPeers();t.length>0&&t.map(async i=>this.listen(i.publicKey)),await this.startOpenChannelListener(),await super.connect(),e||(this._isConnected=P.SECONDARY_TAB_CONNECTED),this.isReady.resolve(!0)}wasDisconnectedByWallet(){return!!this.client.disconnectionEvents.size}closeClient(){this.client.closeSignClient()}async hasPairings(){return await this.client.storage.hasPairings()?!0:!!this.client.signClient?.pairing.getAll()?.length}async hasSessions(){return await this.client.storage.hasSessions()?!0:!!this.client.signClient?.session.getAll()?.length}forceUpdate(e){this.client.storage.notify(e)}async getPeers(){const t=pe.getInstance(this.wcOptions,this.isLeader).currentSession();return t?[{senderId:t.peer.publicKey,extensionId:t.peer.metadata.name,id:t.peer.publicKey,type:"walletconnect-pairing-response",name:t.peer.metadata.name,publicKey:t.peer.publicKey,version:"first"}]:[]}async disconnect(){await this.client.close(),await super.disconnect(),this.isReady=new A}async startOpenChannelListener(){}async doClientCleanup(){await this.client.unsubscribeFromEncryptedMessages()}getPairingRequestInfo(){return this.client.getPairingRequestInfo()}async listen(e){await this.client.listenForEncryptedMessage(e,t=>{const i={origin:R.WALLETCONNECT,id:e};this.notifyListeners(t,i).catch(a=>{throw a})}).catch(t=>{throw t})}}const sn=new U("DappWalletConnectTransport");class nn extends q{constructor(s,e,t,i,a){super(s,e,t,p.TRANSPORT_WALLETCONNECT_PEERS_DAPP,i,a),this.client.listenForChannelOpening(async r=>{await this.addPeer(r),this._isConnected=F(window)||await a()?P.CONNECTED:P.SECONDARY_TAB_CONNECTED,this.isReady.isPending()&&this.isReady.resolve(!0),this.newPeerListener&&(this.newPeerListener(r),this.newPeerListener=void 0)})}async listenForNewPeer(s){this.newPeerListener=s}async stopListeningForNewPeers(){sn.log("stopListeningForNewPeers"),this.newPeerListener=void 0}}const d=new U("DAppClient");class je extends qt{constructor(e){super({storage:e&&e.storage?e.storage:new et,...e});l(this,"description");l(this,"blockExplorer");l(this,"enableAppSwitching");l(this,"enableMetrics");l(this,"userId");l(this,"network");l(this,"events",new fe);l(this,"postMessageTransport");l(this,"p2pTransport");l(this,"walletConnectTransport");l(this,"wcProjectId");l(this,"wcRelayUrl");l(this,"isGetActiveAccountHandled",!1);l(this,"openRequestsOtherTabs",new Set);l(this,"openRequests",new Map);l(this,"_activeAccount",new A);l(this,"_activePeer",new A);l(this,"_initPromise");l(this,"isInitPending",!1);l(this,"activeAccountLoaded");l(this,"appMetadataManager");l(this,"disclaimerText");l(this,"errorMessages");l(this,"featuredWallets");l(this,"storageValidator");l(this,"beaconIDB",new Ze("beacon",["bug_report","metrics"]));l(this,"debounceSetActiveAccount",!1);l(this,"multiTabChannel",new Js("beacon-sdk-channel",this.onBCMessageHandler.bind(this),this.onElectedLeaderhandler.bind(this)));l(this,"blockchains",new Map);this.description=e.description,this.wcProjectId=e.walletConnectOptions?.projectId||"24469fd0a06df227b6e5f7dc7de0ff4f",this.wcRelayUrl=e.walletConnectOptions?.relayUrl,this.featuredWallets=e.featuredWallets,this.events=new fe(e.eventHandlers,e.disableDefaultEvents??!1),this.blockExplorer=e.blockExplorer??new Zs,this.network=e.network??{type:e.preferredNetwork??v.MAINNET},we(e.colorMode??tt.LIGHT),this.disclaimerText=e.disclaimerText,this.errorMessages=e.errorMessages??{},this.appMetadataManager=new Bt(this.storage),this.storageValidator=new xt(this.storage),this.enableAppSwitching=e.enableAppSwitching===void 0?!0:!!e.enableAppSwitching,this.enableMetrics=!!e.enableMetrics,this.storage.subscribeToStorageChanged(async t=>{if(t.eventType==="storageCleared"){this.setActiveAccount(void 0);return}if(t.eventType==="entryModified"){if(t.key===this.storage.getPrefixedKey(p.ACTIVE_ACCOUNT)){const i=t.newValue;if(!i||i==="undefined")this.setActiveAccount(void 0);else{const a=await this.getAccount(i);this.setActiveAccount(a)}return}if(t.key===this.storage.getPrefixedKey(p.ENABLE_METRICS)){this.enableMetrics=!!await this.storage.get(p.ENABLE_METRICS);return}if(t.key===this.storage.getPrefixedKey(p.BEACON_SDK_SECRET_SEED)){this._keyPair=new A,this._beaconId=new A,await this.initSDK();return}}}),this.activeAccountLoaded=this.storage.get(p.ACTIVE_ACCOUNT).then(async t=>{if(t){const i=await this.accountManager.getAccount(t);return await this.setActiveAccount(i),i}else{await this.setActiveAccount(void 0);return}}).catch(async t=>{d.error(t),await this.resetInvalidState(!1),this.events.emit(y.INVALID_ACCOUNT_DEACTIVATED)}),this.handleResponse=async(t,i)=>{const a=t.version==="3"?t.message:t;let r=t.version==="3"?a.blockchainData?.appMetadata:a.appMetadata;if(!r&&t.version==="3"){const u=await Promise.all([this.storage.get(p.TRANSPORT_P2P_PEERS_DAPP),this.storage.get(p.TRANSPORT_WALLETCONNECT_PEERS_DAPP),this.storage.get(p.TRANSPORT_POSTMESSAGE_PEERS_DAPP)]);for(const h of u){const f=h.find(I=>I.senderId===t.senderId);if(!f)continue;const g=await this.getWalletInfo();r={name:f.name,senderId:f.senderId,icon:g.icon};break}}if(this.openRequestsOtherTabs.has(t.id)){this.multiTabChannel.postMessage({type:"RESPONSE",data:{message:t,connectionInfo:i},id:t.id}),a.type!==w.Acknowledge&&this.openRequestsOtherTabs.delete(t.id);return}const o=this.openRequests.get(t.id);d.log("### openRequest ###",o),d.log("handleResponse","Received message",t,i),d.log("### message ###",JSON.stringify(t)),d.log("### connectionInfo ###",i);const c=async()=>{this.analytics.track("event","DAppClient","Disconnect received from Wallet");const u=i.origin===R.P2P?this.p2pTransport:i.origin===R.WALLETCONNECT?this.walletConnectTransport:this.postMessageTransport??await this.transport;if(u){const f=(await u.getPeers()).find(g=>g.senderId===t.senderId);f&&await u.removePeer(f)}await this.removeAccountsForPeerIds([t.senderId]),await this.events.emit(y.CHANNEL_CLOSED)};o&&a.type===w.Acknowledge?(this.analytics.track("event","DAppClient","Acknowledge received from Wallet"),d.log("handleResponse",`acknowledge message received for ${t.id}`),this.events.emit(y.ACKNOWLEDGE_RECEIVED,{message:a,extraInfo:{},walletInfo:await this.getWalletInfo()}).catch(console.error)):o?(a.type===w.PermissionResponse&&r&&await this.appMetadataManager.addAppMetadata(r),a.type===w.Error?o.reject(a):o.resolve({message:t,connectionInfo:i}),this.openRequests.delete(a.id)):a.type===w.Disconnect?await c():a.type===w.ChangeAccountRequest&&await this.onNewAccount(a,i),this._transport.isResolved()&&await this.transport instanceof q&&!this.openRequests.has("session_update")&&this.openRequests.set("session_update",new A)},this.storageValidator.validate().then(async t=>{const i=await this.activeAccountLoaded;if(!t){const a=await this.getWalletInfo(void 0,i,!1);a.type=a.type==="extension"&&i?.origin.type===R.P2P?"mobile":a.type,await this.storage.set(p.LAST_SELECTED_WALLET,{icon:a.icon??"",key:a.name,type:a.type??"web",name:a.name,url:a.deeplink}),await this.storageValidator.validate()||this.resetInvalidState(!1)}i&&i.origin.type!=="p2p"&&this.init()}).catch(t=>d.error(t.message)),this.sendMetrics("enable-metrics?"+this.addQueryParam("version",ne),void 0,t=>{t.ok||(t.status===426?console.error("Metrics are no longer supported for this version, please upgrade."):console.warn("Network error encountered. Metrics sharing have been automatically disabled.")),this.enableMetrics=t.ok,this.storage.set(p.ENABLE_METRICS,t.ok)},()=>{this.enableMetrics=!1,this.storage.set(p.ENABLE_METRICS,!1)}),this.initUserID().catch(t=>d.error(t.message))}async checkIfBCLeaderExists(){return F(window)?!0:await this.multiTabChannel.hasLeader()?this.multiTabChannel.isLeader():(await this.multiTabChannel.getLeadership(),this.multiTabChannel.isLeader())}async onElectedLeaderhandler(){if(!this._transport.isResolved())return;const e=await this.transport;e.type===O.WALLETCONNECT&&e.connectionStatus!==P.CONNECTED&&await e.connect()}async onBCMessageHandler(e){switch(e.type){case w.PermissionRequest:case w.OperationRequest:case w.SignPayloadRequest:case w.BroadcastRequest:case w.ProofOfEventChallengeRequest:case w.SimulatedProofOfEventChallengeRequest:this.prepareRequest(e);break;case w.BlockchainRequest:this.prepareRequest(e,!0);break;case"RESPONSE":this.handleResponse(e.data.message,e.data.connectionInfo);break;case"DISCONNECT":this._transport.isResolved()&&this.disconnect();break;default:d.error("onBCMessageHandler","message type not recognized",e)}}async prepareRequest(e,t=!1){if(!this.multiTabChannel.isLeader())return;await(await this._transport.promise).waitForResolution(),this.openRequestsOtherTabs.add(e.id),t?this.makeRequestV3(e.data,e.id):this.makeRequest(e.data,!1,e.id)}async createStateSnapshot(){if(!localStorage||!this.enableMetrics)return;const e=Object.values(p).filter(t=>!t.includes("wc@2")&&!t.includes("secret")&&!t.includes("account"));try{for(const t of e)await this.beaconIDB.set(t,this.storage.getPrefixedKey(t))}catch(t){d.error("createStateSnapshot",t.message)}}async initUserID(){const e=await this.storage.get(p.USER_ID);if(e){this.userId=e;return}this.userId=await W(),this.storage.set(p.USER_ID,this.userId)}async initInternalTransports(){const e=await this.storage.get(p.BEACON_SDK_SECRET_SEED);if(!e)throw new Error("Secret seed not found");const t=await ie(e);if(this.postMessageTransport||this.p2pTransport||this.walletConnectTransport)return;this.postMessageTransport=new en(this.name,t,this.storage),await this.addListener(this.postMessageTransport),this.p2pTransport=new tn(this.name,t,this.storage,this.matrixNodes,this.iconUrl,this.appUrl),await this.addListener(this.p2pTransport);const i={projectId:this.wcProjectId,relayUrl:this.wcRelayUrl,metadata:{name:this.name,description:this.description??"",url:this.appUrl??"",icons:this.iconUrl?[this.iconUrl]:[]}};this.walletConnectTransport=new nn(this.name,t,this.storage,{network:this.network.type,opts:i},this.checkIfBCLeaderExists.bind(this)),this.initEvents(),await this.addListener(this.walletConnectTransport)}initEvents(){this.walletConnectTransport&&(this.walletConnectTransport.setEventHandler("CLOSE_ALERT",this.hideUI.bind(this,["alert","toast"])),this.walletConnectTransport.setEventHandler("RESET_STATE",this.channelClosedHandler.bind(this)),this.walletConnectTransport.setEventHandler("WC_ACK_NOTIFICATION",this.wcToastHandler.bind(this)),this.walletConnectTransport.setEventHandler("ON_RELAYER_ERROR",this.onRelayerError.bind(this)))}async onRelayerError(){await this.resetInvalidState(!1),this.events.emit(y.RELAYER_ERROR)}async wcToastHandler(e){const t=await(async()=>{try{return await this.getWalletInfo()}catch{return{name:"wallet"}}})();await this.events.emit(y.HIDE_UI,["alert"]),e==="pending"?this.events.emit(y.ACKNOWLEDGE_RECEIVED,{message:{},extraInfo:{},walletInfo:t}):this.events.emit(y.PERMISSION_REQUEST_ERROR,{errorResponse:{errorType:C.ABORTED_ERROR},walletInfo:t})}async channelClosedHandler(e){(await this.transport).type===e&&(await this.events.emit(y.CHANNEL_CLOSED),this.setActiveAccount(void 0),await this.disconnect())}async destroy(){await this.createStateSnapshot(),await super.destroy()}async init(e,t){if(this._initPromise)return this._initPromise;try{await this.activeAccountLoaded}catch{}return this._initPromise=new Promise(async i=>{if(e)await this.addListener(e),i(await super.init(e));else if(this._transport.isSettled())await(await this.transport).connect(),i(await super.init(await this.transport));else{const a=await this.getActiveAccount(),r=()=>{this.postMessageTransport&&this.postMessageTransport.stopListeningForNewPeers().catch(console.error),this.p2pTransport&&this.p2pTransport.stopListeningForNewPeers().catch(console.error),this.walletConnectTransport&&this.walletConnectTransport.stopListeningForNewPeers().catch(console.error)};if(await this.initInternalTransports(),!this.postMessageTransport||!this.p2pTransport||!this.walletConnectTransport)return;if(this.postMessageTransport.connect().then().catch(console.error),a&&a.origin){const o=a.origin.type;o===R.EXTENSION?i(await super.init(this.postMessageTransport)):o===R.P2P?i(await super.init(this.p2pTransport)):o===R.WALLETCONNECT&&i(await super.init(this.walletConnectTransport))}else{const o=this.p2pTransport,c=this.postMessageTransport,u=this.walletConnectTransport;c.listenForNewPeer(m=>{d.log("init","postmessage transport peer connected",m),this.analytics.track("event","DAppClient","Extension connected",{peerName:m.name}),this.events.emit(y.PAIR_SUCCESS,m).catch(_=>console.warn(_)),this.setActivePeer(m).catch(console.error),this.setTransport(this.postMessageTransport).catch(console.error),r(),i(O.POST_MESSAGE)}).catch(console.error),o.listenForNewPeer(m=>{d.log("init","p2p transport peer connected",m),this.analytics.track("event","DAppClient","Beacon Wallet connected",{peerName:m.name}),this.events.emit(y.PAIR_SUCCESS,m).catch(_=>console.warn(_)),this.setActivePeer(m).catch(console.error),this.setTransport(this.p2pTransport).catch(console.error),r(),i(O.P2P)}).catch(console.error),u.listenForNewPeer(m=>{d.log("init","walletconnect transport peer connected",m),this.analytics.track("event","DAppClient","WalletConnect Wallet connected",{peerName:m.name}),this.events.emit(y.PAIR_SUCCESS,m).catch(_=>console.warn(_)),this.setActivePeer(m).catch(console.error),this.setTransport(this.walletConnectTransport).catch(console.error),r(),i(O.WALLETCONNECT)}).catch(console.error),ke.getAvailableExtensions().then(async m=>{this.analytics.track("event","DAppClient","Extensions detected",{extensions:m})}).catch(m=>{this._initPromise=void 0,console.error(m)});const h=async()=>{d.log("init","ABORTED"),this.sendMetrics("performance-metrics/save",await this.buildPayload("connect","abort")),await Promise.all([c.disconnect(),u.disconnect()]),this.postMessageTransport=this.walletConnectTransport=this.p2pTransport=void 0,this._activeAccount.isResolved()&&this.clearActiveAccount(),this._initPromise=void 0},f=new $,g=new Promise(async m=>{try{await o.connect()}catch(_){d.error(_),await this.hideUI(["alert"]),setTimeout(()=>this.events.emit(y.GENERIC_ERROR,_.message),1e3),h(),m("");return}m(await f.serialize(await o.getPairingRequestInfo()))}),I=new Promise(async m=>{m((await u.getPairingRequestInfo()).uri)}),D=new Promise(async m=>{m(await f.serialize(await c.getPairingRequestInfo()))});this.events.emit(y.PAIR_INIT,{p2pPeerInfo:g,postmessagePeerInfo:D,walletConnectPeerInfo:I,networkType:this.network.type,abortedHandler:h.bind(this),disclaimerText:this.disclaimerText,analytics:this.analytics,featuredWallets:this.featuredWallets,substratePairing:t}).catch(m=>console.warn(m))}}}),this._initPromise}async getActiveAccount(){return this._activeAccount.promise}async isInvalidState(e){const t=await this._activeAccount.promise;return t?t?.address!==e?.address&&!this.isGetActiveAccountHandled:!1}async resetInvalidState(e=!0){this.accountManager.removeAllAccounts(),this._activeAccount=A.resolve(void 0),this.storage.set(p.ACTIVE_ACCOUNT,void 0),e&&this.events.emit(y.INVALID_ACTIVE_ACCOUNT_STATE),!e&&this.hideUI(["alert"]),await Promise.all([this.postMessageTransport?.disconnect(),this.walletConnectTransport?.disconnect()]),this.postMessageTransport=this.p2pTransport=this.walletConnectTransport=void 0,await this.setActivePeer(void 0),await this.setTransport(void 0),this._initPromise=void 0}async setActiveAccount(e){if(this.isGetActiveAccountHandled||console.warn(`An active account has been received, but no active subscription was found for BeaconEvent.ACTIVE_ACCOUNT_SET.
        For more information, visit: https://docs.walletbeacon.io/guides/migration-guide`),e&&this._activeAccount.isSettled()&&await this.isInvalidState(e)){const t=await this.transport;if(t instanceof q&&t.wasDisconnectedByWallet()){await this.resetInvalidState();return}}if(!e&&this._activeAccount.isResolved()&&await this.getActiveAccount()){const t=await this.transport,i=await this.getActiveAccount();if(!t||!i)return;!this.debounceSetActiveAccount&&t instanceof q&&(this.debounceSetActiveAccount=!0,this._initPromise=void 0,this.postMessageTransport=this.p2pTransport=this.walletConnectTransport=void 0,this.multiTabChannel.isLeader()||F(window)?(await t.disconnect(),this.openRequestsOtherTabs.clear()):this.multiTabChannel.postMessage({type:"DISCONNECT"}),Array.from(this.openRequests.entries()).filter(([a,r])=>a!=="session_update").forEach(([a,r])=>{r.reject({type:w.Error,errorType:C.ABORTED_ERROR,id:a,senderId:"",version:"2"})}),this.openRequests.clear(),this.debounceSetActiveAccount=!1)}if(this._activeAccount.isSettled()?this._activeAccount=A.resolve(e):this._activeAccount.resolve(e),!this.isGetActiveAccountHandled&&this._transport.isResolved()){const t=await this.transport;if(t instanceof q&&t.wasDisconnectedByWallet()){await this.resetInvalidState();return}}if(e){const t=e.origin.type;if(await this.initInternalTransports(),t===R.EXTENSION?await this.setTransport(this.postMessageTransport):t===R.P2P?await this.setTransport(this.p2pTransport):t===R.WALLETCONNECT&&(await this.setTransport(this.walletConnectTransport),this.walletConnectTransport?.forceUpdate("INIT")),this._transport.isResolved()){const a=await this.transport;a.connectionStatus===P.NOT_CONNECTED&&await a.connect()}const i=await this.getPeer(e);await this.setActivePeer(i)}else await this.setActivePeer(void 0),await this.setTransport(void 0);await this.storage.set(p.ACTIVE_ACCOUNT,e?e.accountIdentifier:void 0),await this.events.emit(y.ACTIVE_ACCOUNT_SET,e)}clearActiveAccount(){return this.setActiveAccount()}async setColorMode(e){return we(e)}async getColorMode(){return st()}async getAppMetadata(){return this.getOwnAppMetadata()}async showPrepare(){const e=await(async()=>{try{return await this.getWalletInfo()}catch{return}})();await this.events.emit(y.SHOW_PREPARE,{walletInfo:e})}async hideUI(e){await this.events.emit(y.HIDE_UI,e)}async tryToAppSwitch(){if(!F(window)||!this.enableAppSwitching)return;const e=await this.getWalletInfo();if(e.type!=="mobile"||!e.deeplink)return;const t=nt(window)?e.deeplink:`${e.deeplink}wc?uri=`;t?.length&&(window.location=t)}addQueryParam(e,t){return e+"="+t}async buildPayload(e,t){const i=await this.storage.get(p.LAST_SELECTED_WALLET),a=this._activeAccount.isResolved()?(await this.getActiveAccount())?.origin.type??"UNKNOWN":"UNKNOWN";return{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({userId:this.userId,os:it(),walletName:i?.name??"init",walletType:i?.type??"init",sdkVersion:ne,transport:a,time:new Date,action:e,status:t})}}async updateMetricsStorage(e){const t=await this.beaconIDB.getAllKeys("metrics");if(t.length>=1e3){const i=t.shift();this.beaconIDB.delete(i.toString(),"metrics")}this.beaconIDB.set(String(Date.now()),e,"metrics")}sendMetrics(e,t,i,a){!this.enableMetrics&&e==="performance-metrics/save"&&t&&this.updateMetricsStorage(t.body),this.enableMetrics&&fetch(`${at}/${e}`,t).then(r=>i&&i(r)).catch(r=>{console.warn("Network error encountered. Metrics sharing have been automatically disabled."),d.error(r.message),this.enableMetrics=!1,a&&a(r)})}async checkMakeRequest(){const e=this._transport.isResolved(),t=e&&await this.transport instanceof q;await this.multiTabChannel.init();const i=this.multiTabChannel.isLeader();return!e||!t||i||F(window)}async removeAccount(e){const t=super.removeAccount(e),i=await this.getActiveAccount();return i&&i.accountIdentifier===e&&await this.setActiveAccount(void 0),t}async removeAllAccounts(){await super.removeAllAccounts(),await this.setActiveAccount(void 0)}async removePeer(e,t=!1){const i=await this.transport,a=i.removePeer(e);return await this.removeAccountsForPeers([e]),t&&await this.sendDisconnectToPeer(e,i),a}async removeAllPeers(e=!1){const t=await this.transport,i=await t.getPeers(),a=t.removeAllPeers();if(await this.removeAccountsForPeers(i),e){const r=i.map(o=>this.sendDisconnectToPeer(o,t));await Promise.all(r)}return a}async subscribeToEvent(e,t){e===y.ACTIVE_ACCOUNT_SET&&(this.isGetActiveAccountHandled=!0),await this.events.on(e,t)}async checkPermissions(e){if([w.PermissionRequest,w.ProofOfEventChallengeRequest,w.SimulatedProofOfEventChallengeRequest].includes(e))return!0;const t=await this.getActiveAccount();if(!t)throw await this.sendInternalError("No active account set!");const i=t.scopes;switch(e){case w.OperationRequest:return i.includes(N.OPERATION_REQUEST);case w.SignPayloadRequest:return i.includes(N.SIGN);case w.BroadcastRequest:return!0;default:return!1}}async sendNotification(e,t,i,a){const r=await this.getActiveAccount();if(!r||r&&!r.scopes.includes(N.NOTIFICATION)&&!r.notification)throw new Error("notification permissions not given");if(!r.notification?.token)throw new Error("No AccessToken");const o=r.notification?.apiUrl;if(!o)throw new Error("No Push URL set");return this.sendNotificationWithAccessToken({url:o,recipient:r.address,title:e,body:t,payload:i,protocolIdentifier:a,accessToken:r.notification?.token})}addBlockchain(e){this.blockchains.set(e.identifier,e),e.getWalletLists().then(t=>{rt(t.desktopList),ot(t.extensionList),ct(t.webList),lt(t.iOSList)})}removeBlockchain(e){this.blockchains.delete(e)}async permissionRequest(e){d.log("permissionRequest",e);const t=this.blockchains.get(e.blockchainIdentifier);if(!t)throw new Error(`Blockchain "${e.blockchainIdentifier}" not supported by dAppClient`);const i={...e,type:w.PermissionRequest,blockchainData:{...e.blockchainData,appMetadata:await this.getOwnAppMetadata()}};d.log("REQUESTION PERMIMISSION V3","xxx",i),this.sendMetrics("performance-metrics/save",await this.buildPayload("connect","start"));const a=`makeRequestV3 ${Date.now()}`;d.time(!0,a);const{message:r,connectionInfo:o}=await this.makeRequestV3(i).catch(async h=>{throw h.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),d.time(!1,a),await this.handleRequestError(i,h)});d.time(!1,a),this.sendMetrics("performance-metrics/save",await this.buildPayload("connect","start")),d.log("RESPONSE V3",r,o);const c=await t.getAccountInfosFromPermissionResponse(r.message),u={accountIdentifier:c[0].accountId,senderId:r.senderId,origin:{type:o.origin,id:o.id},address:c[0].address,publicKey:c[0].publicKey,scopes:r.message.blockchainData.scopes,connectedAt:new Date().getTime(),chainData:r.message.blockchainData};return await this.accountManager.addAccount(u),await this.setActiveAccount(u),await t.handleResponse({request:i,account:u,output:r,blockExplorer:this.blockExplorer,connectionContext:o,walletInfo:await this.getWalletInfo()}),await this.notifySuccess(i,{account:u,output:{address:c[0].address,network:{type:"substrate"},scopes:[]},blockExplorer:this.blockExplorer,connectionContext:o,walletInfo:await this.getWalletInfo()}),r.message}async request(e){d.log("request",e);const t=this.blockchains.get(e.blockchainIdentifier);if(!t)throw new Error(`Blockchain "${t}" not supported by dAppClient`);await t.validateRequest(e);const i=await this.getActiveAccount();if(!i)throw await this.sendInternalError("No active account!");const a={...e,type:w.BlockchainRequest,accountId:i.accountIdentifier};this.sendMetrics("performance-metrics/save",await this.buildPayload("message","start"));const r=`makeRequestV3 ${Date.now()}`;d.time(!0,r);const o=await this.checkMakeRequest()?this.makeRequestV3(a):this.makeRequestBC(a);o.catch(async h=>{throw h.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),d.time(!1,r),await this.handleRequestError(a,h)});const{message:c,connectionInfo:u}=await o;return d.time(!1,r),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","success")),await t.handleResponse({request:a,account:i,output:c,blockExplorer:this.blockExplorer,connectionContext:u,walletInfo:await this.getWalletInfo()}),await this.notifySuccess(a,{walletInfo:await this.getWalletInfo()}),c.message}async requestPermissions(e){if(e?.network)throw new Error('[BEACON] the "network" property is no longer accepted in input. Please provide it when instantiating DAppClient.');const t={appMetadata:await this.getOwnAppMetadata(),type:w.PermissionRequest,network:this.network,scopes:e&&e.scopes?e.scopes:[N.OPERATION_REQUEST,N.SIGN]};this.analytics.track("event","DAppClient","Permission requested"),this.sendMetrics("performance-metrics/save",await this.buildPayload("connect","start"));const i=`makeRequest ${Date.now()}`;d.time(!0,i);const a=await this.checkMakeRequest()||!await this.getActiveAccount()?this.makeRequest(t,void 0,void 0):this.makeRequestBC(t);a.catch(async h=>{throw h.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),d.time(!1,i),await this.handleRequestError(t,h)});const{message:r,connectionInfo:o}=await a;d.time(!1,i),this.sendMetrics("performance-metrics/save",await this.buildPayload("connect","success")),d.log("requestPermissions","######## MESSAGE #######"),d.log("requestPermissions",r);const c=await this.onNewAccount(r,o);d.log("requestPermissions","######## ACCOUNT INFO #######"),d.log("requestPermissions",JSON.stringify(c)),await this.accountManager.addAccount(c);const u={...r,walletKey:c.walletKey,address:c.address,accountInfo:c};return await this.notifySuccess(t,{account:c,output:u,blockExplorer:this.blockExplorer,connectionContext:o,walletInfo:await this.getWalletInfo()}),this.analytics.track("event","DAppClient","Permission received",{address:c.address}),u}async requestProofOfEventChallenge(e){const t=await this.getActiveAccount();if(!t)throw new Error("Please request permissions before doing a proof of event challenge");if(t.walletType!=="abstracted_account"&&t.verificationType!=="proof_of_event")throw new Error("This wallet is not an abstracted account and thus cannot perform proof of event");const i={type:w.ProofOfEventChallengeRequest,contractAddress:t.address,payload:e.payload};this.sendMetrics("performance-metrics/save",await this.buildPayload("message","start"));const a=`makeRequest ${Date.now()}`;d.time(!0,a);const r=await this.checkMakeRequest()?this.makeRequest(i):this.makeRequestBC(i);r.catch(async u=>{throw u.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),d.time(!1,a),await this.handleRequestError(i,u)});const{message:o,connectionInfo:c}=await r;return d.time(!1,a),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","success")),this.analytics.track("event","DAppClient",`Proof of event challenge ${o.isAccepted?"accepted":"refused"}`,{address:t.address}),await this.notifySuccess(i,{account:t,output:o,blockExplorer:this.blockExplorer,connectionContext:c,walletInfo:await this.getWalletInfo()}),o}async requestSimulatedProofOfEventChallenge(e){const t=await this.getActiveAccount();if(!t)throw new Error("Please request permissions before doing a proof of event challenge");if(t.walletType!=="abstracted_account"&&t.verificationType!=="proof_of_event")throw new Error("This wallet is not an abstracted account and thus cannot perform a simulated proof of event");const i={type:w.SimulatedProofOfEventChallengeRequest,contractAddress:t.address,...e},a=`makeRequest ${Date.now()}`;d.time(!0,a);const r=await this.checkMakeRequest()?this.makeRequest(i):this.makeRequestBC(i);r.catch(async u=>{throw u.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),d.time(!1,a),await this.handleRequestError(i,u)});const{message:o,connectionInfo:c}=await r;return d.time(!1,a),this.analytics.track("event","DAppClient",`Simulated proof of event challenge ${o.errorMessage?"refused":"accepted"}`,{address:t.address}),await this.notifySuccess(i,{account:t,output:o,blockExplorer:this.blockExplorer,connectionContext:c,walletInfo:await this.getWalletInfo()}),o}async requestSignPayload(e){if(!e.payload)throw await this.sendInternalError("Payload must be provided");const t=await this.getActiveAccount();if(!t)throw await this.sendInternalError("No active account!");const i=e.payload;if(typeof i!="string")throw new Error("Payload must be a string");const a=(()=>{switch(e.signingType){case b.OPERATION:if(!i.startsWith("03"))throw new Error('When using signing type "OPERATION", the payload must start with prefix "03"');return b.OPERATION;case b.MICHELINE:if(!i.startsWith("05"))throw new Error('When using signing type "MICHELINE", the payload must start with prefix "05"');return b.MICHELINE;case b.RAW:default:return b.RAW}})();this.analytics.track("event","DAppClient","Signature requested");const r={type:w.SignPayloadRequest,signingType:a,payload:i,sourceAddress:e.sourceAddress||t.address};this.sendMetrics("performance-metrics/save",await this.buildPayload("message","start"));const o=`makeRequest ${Date.now()}`;d.time(!0,o);const c=await this.checkMakeRequest()?this.makeRequest(r):this.makeRequestBC(r);c.catch(async f=>{throw f.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),d.time(!1,o),await this.handleRequestError(r,f)});const{message:u,connectionInfo:h}=await c;return d.time(!1,o),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","success")),await this.notifySuccess(r,{account:t,output:u,connectionContext:h,walletInfo:await this.getWalletInfo()}),this.analytics.track("event","DAppClient","Signature response"),u}async requestOperation(e){if(!e.operationDetails)throw await this.sendInternalError("Operation details must be provided");const t=await this.getActiveAccount();if(!t)throw await this.sendInternalError("No active account!");const i={type:w.OperationRequest,network:t.network||this.network,operationDetails:e.operationDetails,sourceAddress:t.address||""};this.analytics.track("event","DAppClient","Operation requested"),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","start"));const a=`makeRequest ${Date.now()}`;d.time(!0,a);const r=await this.checkMakeRequest()?this.makeRequest(i):this.makeRequestBC(i);r.catch(async u=>{throw u.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),d.time(!1,a),await this.handleRequestError(i,u)});const{message:o,connectionInfo:c}=await r;return d.time(!1,a),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","success")),await this.notifySuccess(i,{account:t,output:o,blockExplorer:this.blockExplorer,connectionContext:c,walletInfo:await this.getWalletInfo()}),this.analytics.track("event","DAppClient","Operation response"),o}async requestBroadcast(e){if(!e.signedTransaction)throw await this.sendInternalError("Signed transaction must be provided");e.network!==void 0&&this.network.type!==e.network?.type&&console.error("[BEACON] The network specified in the DAppClient constructor does not match the network set in the broadcast request. Please set the network in the constructor. Setting it during the Broadcast Request is deprecated.");const t={type:w.BroadcastRequest,network:this.network,signedTransaction:e.signedTransaction};this.analytics.track("event","DAppClient","Broadcast requested"),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","start"));const i=`makeRequest ${Date.now()}`;d.time(!0,i);const a=await this.checkMakeRequest()?this.makeRequest(t):this.makeRequestBC(t);a.catch(async c=>{throw c.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),d.time(!1,i),await this.handleRequestError(t,c)});const{message:r,connectionInfo:o}=await a;return d.time(!1,i),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","success")),await this.notifySuccess(t,{network:this.network,output:r,blockExplorer:this.blockExplorer,connectionContext:o,walletInfo:await this.getWalletInfo()}),this.analytics.track("event","DAppClient","Broadcast response"),r}async setActivePeer(e){this._activePeer.isSettled()?this._activePeer=A.resolve(e):this._activePeer.resolve(e),e&&(await this.initInternalTransports(),e.type==="postmessage-pairing-response"?await this.setTransport(this.postMessageTransport):e.type==="p2p-pairing-response"&&await this.setTransport(this.p2pTransport))}async setTransport(e){e||(this._initPromise=void 0);const t=super.setTransport(e),i=e?{...e}:void 0;return i&&(i.client={...i.client,keyPair:void 0}),await this.events.emit(y.ACTIVE_TRANSPORT_SET,i),t}async sendInternalError(e){throw await this.events.emit(y.INTERNAL_ERROR,{text:e}),new Error(e)}async removeAccountsForPeers(e){const t=e.map(i=>i.senderId);return this.removeAccountsForPeerIds(t)}async removeAccountsForPeerIds(e){const a=(await this.accountManager.getAccounts()).filter(o=>e.includes(o.senderId)).map(o=>o.accountIdentifier);await this.accountManager.removeAccounts(a);const r=await this.getActiveAccount();r&&a.includes(r.accountIdentifier)&&await this.setActiveAccount(void 0)}async handleRequestError(e,t){if(d.error("handleRequestError","error response",t),t.errorType){const i=[];if(t.errorType===C.NO_PRIVATE_KEY_FOUND_ERROR){const o=async()=>{const c=e;let u;if(c.sourceAddress&&c.network){const h=await ae(c.sourceAddress,c.network);u=await this.getAccount(h),u&&await this.removeAccount(u.accountIdentifier)}};i.push({text:"Remove account",actionCallback:o})}const a=await this.getPeer(),r=await this.getActiveAccount();throw e.type===w.PermissionRequest&&await this.getActiveAccount()===void 0&&(this._initPromise=void 0,this.postMessageTransport=void 0,this.p2pTransport=void 0,this.walletConnectTransport=void 0,await this.setTransport(),await this.setActivePeer()),this.events.emit(K[e.type].error,{errorResponse:t,walletInfo:await this.getWalletInfo(a,r),errorMessages:this.errorMessages},i).catch(o=>d.error("handleRequestError",o)),dt(t.errorType,t.errorData)}throw t}async notifySuccess(e,t){this.events.emit(K[e.type].success,t).catch(i=>console.warn(i))}async getWalletInfoFromStorage(){return await this.storage.get(p.LAST_SELECTED_WALLET)}async updateStorageWallet(e){const t=await this.storage.get(p.LAST_SELECTED_WALLET);t&&(t.name=e.name,t.icon=e.icon??t.icon,this.storage.set(p.LAST_SELECTED_WALLET,t))}async getWalletInfo(e,t,i=!0){const a=t||await this.getActiveAccount(),r=e||await this.getPeer(a);let o;a&&(o=await this.appMetadataManager.getAppMetadata(a.senderId));let c;i&&(c=await this.getWalletInfoFromStorage()),o||(o={name:r?.name??c?.key??"",icon:r?.icon??c?.icon,type:c?.type},this.updateStorageWallet(o));const u=(E,he)=>E&&he?E.toLowerCase()===he.toLowerCase():!1,h=E=>E.split(/[_\s]+/)[0],f=[...ut(),...ht(),...pt(),...ft()].filter(E=>u(h(E.key),h(o?.name??"wallet"))),g=f.find(E=>E.universalLink||E.key.includes("ios")||E.key.includes("mobile")),I=f.find(E=>E.links),D=f.find(E=>E.downloadLink),m=f.find(E=>E.id),_={extension:{app:m,type:"extension"},desktop:{app:D,type:"desktop"},mobile:{app:g,type:"mobile"},web:{app:I,type:"web"}},Y=()=>ye(window)&&I?{app:I,type:"web"}:vt(window)&&D?{app:D,type:"desktop"}:ye(window)&&m?{app:m,type:"extension"}:g?{app:g,type:"mobile"}:{app:void 0,type:void 0},{app:L,type:ue}=c?_[c.type]:Y();if(L){let E;return L.hasOwnProperty("links")?E=L.links[a?.network.type??this.network.type]:L.hasOwnProperty("deepLink")&&(E=L.deepLink),{name:L?.name??o.name,icon:L?.logo??o.icon,deeplink:E,type:ue}}return o}async getPeer(e){let t;if(e){d.log("getPeer","We have an account",e);const i=await this.postMessageTransport?.getPeers()??[],a=await this.p2pTransport?.getPeers()??[],r=await this.walletConnectTransport?.getPeers()??[],o=[...i,...a,...r];d.log("getPeer","Found peers",o,e),t=o.find(c=>c.senderId===e.senderId),t||(t=o.find(c=>c.id===e.origin.id))}else t=await this._activePeer.promise,d.log("getPeer","Active peer",t);return t}async makeRequest(e,t,i){const a=i??await W();if(this._initPromise&&this.isInitPending&&(await Promise.all([this.postMessageTransport?.disconnect(),this.walletConnectTransport?.disconnect()]),this._initPromise=void 0,this.hideUI(["toast"])),d.log("makeRequest","starting"),this.isInitPending=!0,await this.init(),this.isInitPending=!1,d.log("makeRequest","after init"),await this.addRequestAndCheckIfRateLimited())throw this.events.emit(y.LOCAL_RATE_LIMIT_REACHED).catch(g=>console.warn(g)),new Error("rate limit reached");if(!await this.checkPermissions(e.type))throw this.events.emit(y.NO_PERMISSIONS).catch(g=>console.warn(g)),new Error("No permissions to send this request to wallet!");if(!this.beaconId)throw await this.sendInternalError("BeaconID not defined");const r={id:a,version:"2",senderId:await Q(await this.beaconId),...e};let o;t||(o=new A,this.addOpenRequest(r.id,o));const c=await new $().serialize(r),u=await this.getActiveAccount(),h=await this.getPeer(u),f=await this.getWalletInfo(h,u);d.log("makeRequest","sending message",r);try{(await this.transport).send(c,h),(r.type!==w.PermissionRequest||this._activeAccount.isResolved()&&await this._activeAccount.promise)&&this.tryToAppSwitch()}catch(g){throw this.events.emit(y.INTERNAL_ERROR,{text:"Unable to send message. If this problem persists, please reset the connection and pair your wallet again.",buttons:[{text:"Reset Connection",actionCallback:async()=>{me(),this.disconnect()}}]}),g}return i||this.events.emit(K[e.type].sent,{walletInfo:{...f,name:f.name??"Wallet"},extraInfo:{resetCallback:async()=>{this.disconnect()}}}).catch(g=>console.warn(g)),o?.promise}async makeRequestV3(e,t){this._initPromise&&this.isInitPending&&(await Promise.all([this.postMessageTransport?.disconnect(),this.walletConnectTransport?.disconnect()]),this._initPromise=void 0,this.hideUI(["toast"]));const i=t??await W();if(d.log("makeRequest","starting"),this.isInitPending=!0,await this.init(void 0,!0),this.isInitPending=!1,d.log("makeRequest","after init"),await this.addRequestAndCheckIfRateLimited())throw this.events.emit(y.LOCAL_RATE_LIMIT_REACHED).catch(g=>console.warn(g)),new Error("rate limit reached");if(!this.beaconId)throw await this.sendInternalError("BeaconID not defined");const a={id:i,version:"3",senderId:await Q(await this.beaconId),message:e},r=new A;this.addOpenRequest(a.id,r);const o=await new $().serialize(a),c=await this.getActiveAccount(),u=await this.getPeer(c),h=await this.getWalletInfo(u,c);d.log("makeRequest","sending message",a);try{(await this.transport).send(o,u),(a.message.type!==w.PermissionRequest||this._activeAccount.isResolved()&&await this._activeAccount.promise)&&this.tryToAppSwitch()}catch(g){throw this.events.emit(y.INTERNAL_ERROR,{text:"Unable to send message. If this problem persists, please reset the connection and pair your wallet again.",buttons:[{text:"Reset Connection",actionCallback:async()=>{me(),this.disconnect()}}]}),g}const f=e.type;return this.events.emit(K[f].sent,{walletInfo:{...h,name:h.name??"Wallet"},extraInfo:{resetCallback:async()=>{this.disconnect()}}}).catch(g=>console.warn(g)),r.promise}async makeRequestBC(e){if(!this._transport.isResolved()||(await this.transport).type!==O.WALLETCONNECT)return;if(await this.addRequestAndCheckIfRateLimited())throw this.events.emit(y.LOCAL_RATE_LIMIT_REACHED).catch(r=>console.warn(r)),new Error("rate limit reached");const i=await W();this.multiTabChannel.postMessage({type:e.type,data:e,id:i}),(e.type!==w.PermissionRequest||this._activeAccount.isResolved()&&await this._activeAccount.promise)&&this.tryToAppSwitch(),this.events.emit(K[w.PermissionRequest].sent,{walletInfo:await this.getWalletInfo(),extraInfo:{resetCallback:()=>this.disconnect()}}).catch(r=>console.warn(r));const a=new A;return this.addOpenRequest(i,a),a.promise}async disconnect(){if(!this._transport.isResolved())throw new Error("No transport available.");const e=await this.transport;if(e.connectionStatus===P.NOT_CONNECTED)throw new Error("Not connected.");await this.createStateSnapshot(),this.sendMetrics("performance-metrics/save",await this.buildPayload("disconnect","start")),await this.clearActiveAccount(),e instanceof q||await e.disconnect(),this.postMessageTransport=void 0,this.p2pTransport=void 0,this.walletConnectTransport=void 0,this.sendMetrics("performance-metrics/save",await this.buildPayload("disconnect","success"))}addOpenRequest(e,t){d.log("addOpenRequest",this.name,`adding request ${e} and waiting for answer`),this.openRequests.set(e,t)}async sendNotificationWithAccessToken(e){const{url:t,recipient:i,title:a,body:r,payload:o,protocolIdentifier:c,accessToken:u}=e,h=new Date().toISOString(),f=await this.keyPair,g=f.publicKey,I=Buffer.from(new Uint8Array([13,15,37,217])),D=Se.encode(Buffer.concat([I,Buffer.from(g)])),m=["Tezos Signed Message: ",i,a,r,h,o].join(" "),_=Re(m),Y="0501"+_.length.toString(16).padStart(8,"0")+_,L=await wt(Y,{secretKey:Buffer.from(f.secretKey)});return(await Ce.post(`${t}/send`,{recipient:i,title:a,body:r,timestamp:h,payload:o,accessToken:u,protocolIdentifier:c,sender:{name:this.name,publicKey:D,signature:L}})).data}async onNewAccount(e,t){const i=e.publicKey||e.pubkey||e.pubKey,a=i?mt(i):void 0;if(!a&&!e.address)throw new Error("PublicKey or Address must be defined");const r=e.address??await gt(a);if(!yt(r))throw new Error(`Invalid address: "${r}"`);if(e.walletType==="abstracted_account"&&r.substring(0,3)!==ge)throw new Error(`Invalid abstracted account address "${r}", it should be a ${ge} address`);d.log("######## MESSAGE #######"),d.log("onNewAccount",e);const o=(await this.storage.get(p.LAST_SELECTED_WALLET))?.key,c={accountIdentifier:await ae(r,e.network),senderId:e.senderId,origin:{type:t.origin,id:t.id},walletKey:o,address:r,publicKey:a,network:e.network,scopes:e.scopes,threshold:e.threshold,notification:e.notification,connectedAt:new Date().getTime(),walletType:e.walletType??"implicit",verificationType:e.verificationType,...e.verificationType==="proof_of_event"?{hasVerifiedChallenge:!1}:{}};return d.log("accountInfo","######## ACCOUNT INFO #######"),d.log("accountInfo",c),await this.accountManager.addAccount(c),await this.setActiveAccount(c),c}}let M;const an=(n,s)=>(M&&s&&(M.disconnect(),M=void 0),M||(M||(M=new je(n)),M));function T(n,s,e,t){function i(a){return a instanceof e?a:new e(function(r){r(a)})}return new(e||(e=Promise))(function(a,r){function o(h){try{u(t.next(h))}catch(f){r(f)}}function c(h){try{u(t.throw(h))}catch(f){r(f)}}function u(h){h.done?a(h.value):i(h.value).then(o,c)}u((t=t.apply(n,[])).next())})}class se extends Me{constructor(){super(),this.name="BeaconWalletNotInitialized",this.message='BeaconWallet needs to be initialized by calling `await BeaconWallet.requestPermissions({network: {type: "chosen_network"}})` first.'}}class rn extends Me{constructor(s){super(),this.requiredScopes=s,this.name="MissingRequiredScopes",this.message=`Required permissions scopes: ${s.join(",")} were not granted.`}}let on=class{constructor(s){this.client=an(s)}validateRequiredScopesOrFail(s,e){const t=new Set(e);for(const i of s)t.has(i)&&t.delete(i);if(t.size>0)throw new rn(Array.from(t))}requestPermissions(s){return T(this,void 0,void 0,function*(){yield this.client.requestPermissions(s)})}getPKH(){return T(this,void 0,void 0,function*(){const s=yield this.client.getActiveAccount();if(!s)throw new se;return s.address})}getPK(){return T(this,void 0,void 0,function*(){var s;const e=yield this.client.getActiveAccount();if(!e)throw new se;return(s=e.publicKey)!==null&&s!==void 0?s:""})}mapTransferParamsToWalletParams(s){return T(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield j(this.formatParameters(e)))})}mapTransferTicketParamsToWalletParams(s){return T(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield Rt(this.formatParameters(e)))})}mapStakeParamsToWalletParams(s){return T(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield j(this.formatParameters(e)))})}mapUnstakeParamsToWalletParams(s){return T(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield j(this.formatParameters(e)))})}mapFinalizeUnstakeParamsToWalletParams(s){return T(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield j(this.formatParameters(e)))})}mapIncreasePaidStorageWalletParams(s){return T(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield bt(this.formatParameters(e)))})}mapOriginateParamsToWalletParams(s){return T(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield It(this.formatParameters(e)))})}mapDelegateParamsToWalletParams(s){return T(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield Lt(this.formatParameters(e)))})}formatParameters(s){return s.fee&&(s.fee=s.fee.toString()),s.storageLimit&&(s.storageLimit=s.storageLimit.toString()),s.gasLimit&&(s.gasLimit=s.gasLimit.toString()),s}removeDefaultParams(s,e){return s.fee||delete e.fee,s.storageLimit||delete e.storage_limit,s.gasLimit||delete e.gas_limit,e}sendOperations(s){return T(this,void 0,void 0,function*(){const e=yield this.client.getActiveAccount();if(!e)throw new se;const t=e.scopes;this.validateRequiredScopesOrFail(t,[N.OPERATION_REQUEST]);const{transactionHash:i}=yield this.client.requestOperation({operationDetails:s});return i})}disconnect(){return T(this,void 0,void 0,function*(){yield this.client.destroy()})}clearActiveAccount(){return T(this,void 0,void 0,function*(){yield this.client.setActiveAccount()})}sign(s,e){return T(this,void 0,void 0,function*(){let t=At(s);typeof e<"u"&&(t=Tt(e,t));const i=Pt(_t(t)),a=this.getSigningType(e);if(a!==b.OPERATION)throw new Ct(`Taquito Beacon Wallet currently only supports signing operations, not ${a}`);const{signature:r}=yield this.client.requestSignPayload({payload:i,signingType:a});return r})}getSigningType(s){if(!s||s.length===0)return b.RAW;if(s.length===1){if(s[0]===5)return b.MICHELINE;if(s[0]===3)return b.OPERATION}throw new Error(`Invalid watermark ${JSON.stringify(s)}`)}};const cn=(n,s)=>{const e=n,t={childList:!0},i=new MutationObserver(async a=>{for(const r of a)if(r.type==="childList")for(const o of r.addedNodes)s(o,i)});i.observe(e,t)},ln=(n,s)=>{const e=n,t={childList:!0},i=new MutationObserver(async a=>{for(const r of a)if(r.type==="childList")for(const o of r.removedNodes)s(o,i)});i.observe(e,t)},dn=(n,s)=>{const e=document.createElement("style");e.innerHTML=s,n.appendChild(e)};function un(n,s){return(e,t)=>{const i=e;if(typeof i.id=="string"&&i.id.startsWith("beacon-alert-wrapper")){if(t.disconnect(),n.client.connectionStatus!=="NOT_CONNECTED")return;s(kt)}}}function hn(n,s){return async(e,t)=>{const i=e;if(typeof i.id=="string"&&i.id.startsWith("beacon-alert-wrapper")){const a=i?.shadowRoot;if(!a)return;const r=await Ce({method:"get",url:"/assets/styles/beacon.css"});dn(a,r.data),t.disconnect(),ln(document.body,un(n,s))}}}const pn=async(n,s)=>{const e=new Promise((i,a)=>{cn(document.body,hn(n,a))}),t=n.requestPermissions(s);await Promise.race([e,t])};class re extends on{constructor(e){super(e);l(this,"account");l(this,"subscribers",new Set)}async initialize(){return await this.client.subscribeToEvent(y.ACTIVE_ACCOUNT_SET,e=>{this.handleAccountSwitch(e)}),this}static async restore(e){const t=new re(e);if(!await t.client.getActiveAccount()){ve(t.disconnect());return}return await t.initialize()}static async create(e){const t=new re(e);await t.client.getActiveAccount()&&ve(t.disconnect()),t.client=new je(e),await t.initialize();const a=new Promise(async r=>{const o=t.subscribeToAccountSwitch(c=>{r(!0),o()})});return await pn(t),await Promise.all([a]),t}async handleAccountSwitch(e){this.account=e,this.subscribers.forEach(t=>t(e))}subscribeToAccountSwitch(e){return this.subscribers.add(e),this.account&&e(this.account),()=>{this.subscribers.delete(e)}}async disconnect(){await super.disconnect(),await super.clearActiveAccount()}}export{re as BeaconWallet};
