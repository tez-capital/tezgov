var we=Object.defineProperty;var fe=(u,s,e)=>s in u?we(u,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[s]=e;var d=(u,s,e)=>(fe(u,typeof s!="symbol"?s+"":s,e),e);import{g as ge,E as P,w as x,S as h,a as G,t as re,b as Y,c as D,d as ye,e as me,f as Ae,B as w,P as R,h as oe,T as v,i as B,j as N,k as F,L as _,l as ce,m as Te,n as le,O as T,N as m,o as de,W as Z,p as ee,I as Pe,q as Ee,s as te,C as ve,r as f,u as C,v as Ie,x as Ce,y as Re,z as be,A as Se,D as Ne,F as _e,G as ke,H as E,J as W,K as Oe,M as Me,Q as Le,R as De,U as qe,V as se,X as xe,Y as We,Z as he,_ as Ue,$ as Be,a0 as Fe,a1 as ie,a2 as ne,a3 as Ve,a4 as pe,a5 as U,a6 as Ke,a7 as $e,a8 as He,a9 as ze,aa as Ge,ab as je,ac as Qe,ad as ae}from"./Input.7KAJUYnN.js";/*! typedarray-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var Je=function(s){return ArrayBuffer.isView(s)?Buffer.from(s.buffer,s.byteOffset,s.byteLength):Buffer.from(s)};const Xe=ge(Je);class Ye{track(s,e,t,i){}}class Ze{constructor(s){d(this,"name");d(this,"iconUrl");d(this,"appUrl");d(this,"_beaconId",new P);d(this,"storage");d(this,"analytics");d(this,"_keyPair",new P);if(!s.name)throw new Error("Name not set");if(!s.storage)throw new Error("Storage not set");this.name=s.name,this.iconUrl=s.iconUrl,this.appUrl=s.appUrl??x.location.origin,this.storage=s.storage,this.analytics=s.analytics??new Ye,x.beaconCreatedClientInstance?console.error("[BEACON] It looks like you created multiple Beacon SDK Client instances. This can lead to problems. Only create one instance and re-use it everywhere."):x.beaconCreatedClientInstance=!0,this.initSDK().catch(console.error)}get beaconId(){return this._beaconId.promise}get keyPair(){return this._keyPair.promise}async destroy(){await this.removeBeaconEntriesFromStorage(),x.beaconCreatedClientInstance=!1}async initSDK(){return this.storage.set(h.BEACON_SDK_VERSION,G).catch(console.error),this.loadOrCreateBeaconSecret().catch(console.error),this.keyPair.then(s=>{this._beaconId.resolve(re(s.publicKey))})}async removeBeaconEntriesFromStorage(){const s=Object.values(h);await Promise.all(s.map(e=>this.storage.delete(e)))}async loadOrCreateBeaconSecret(){const s=await this.storage.get(h.BEACON_SDK_SECRET_SEED);if(s&&typeof s=="string")this._keyPair.resolve(await Y(s));else{const e=await D();await this.storage.set(h.BEACON_SDK_SECRET_SEED,e),this._keyPair.resolve(await Y(e))}}}const j=async(u,s)=>{const e=[u,s.type];s.name&&e.push(`name:${s.name}`),s.rpcUrl&&e.push(`rpc:${s.rpcUrl}`);const t=Buffer.from(ye.hash(me(e.join("-")),10));return Ae.encode(t)};class et{static async hasPermission(s,e,t){switch(s.type){case w.PermissionRequest:case w.BroadcastRequest:return!0;case w.OperationRequest:{const i=await j(s.sourceAddress,s.network),n=await e(i);return n?n.scopes.includes(R.OPERATION_REQUEST):!1}case w.SignPayloadRequest:{const n=(await t()).filter(a=>a.address===s.sourceAddress);return n.length===0?!1:n.some(a=>a.scopes.includes(R.SIGN))}default:throw new Error("Message not handled")}}}class tt{constructor(s){d(this,"storageManager");this.storageManager=new oe(s,h.ACCOUNTS)}async getAccounts(){return await this.storageManager.getAll()??[]}async getAccount(s){return this.storageManager.getOne(e=>e.accountIdentifier===s)}async addAccount(s){return this.storageManager.addOne(s,e=>e.accountIdentifier===s.accountIdentifier)}async updateAccount(s,e){const t=await this.getAccount(s);if(!t)return;const i={...t,...e};return await this.storageManager.addOne(i,n=>n.accountIdentifier===s,!0),i}async removeAccount(s){return this.storageManager.remove(e=>e.accountIdentifier===s)}async removeAccounts(s){return this.storageManager.remove(e=>s.includes(e.accountIdentifier))}async removeAllAccounts(){return this.storageManager.removeAll()}async hasPermission(s){return et.hasPermission(s,this.getAccount.bind(this),this.getAccounts.bind(this))}}const st=new _("Client");class it extends Ze{constructor(e){super(e);d(this,"accountManager");d(this,"handleResponse");d(this,"rateLimit",2);d(this,"rateLimitWindowInSeconds",5);d(this,"requestCounter",[]);d(this,"matrixNodes");d(this,"transportListeners",new Map);d(this,"_transport",new P);this.accountManager=new tt(e.storage),this.matrixNodes=e.matrixNodes??{},this.handleResponse=(t,i)=>{throw new Error(`not overwritten${JSON.stringify(t)} - ${JSON.stringify(i)}`)}}get transport(){return this._transport.promise}get connectionStatus(){return this._transport.promiseResult?.connectionStatus??v.NOT_CONNECTED}get ready(){return this.transport.then(()=>{})}async cleanup(){if(this.transportListeners.size&&this._transport.isResolved()){const e=await this.transport;await Promise.all(Array.from(this.transportListeners.values()).map(t=>e.removeListener(t))),this.transportListeners.clear()}}async getAccounts(){return this.accountManager.getAccounts()}async getAccount(e){return this.accountManager.getAccount(e)}async removeAccount(e){return this.accountManager.removeAccount(e)}async removeAllAccounts(){return this.accountManager.removeAllAccounts()}async addRequestAndCheckIfRateLimited(){const e=new Date().getTime();return this.requestCounter=this.requestCounter.filter(t=>t+this.rateLimitWindowInSeconds*1e3>e),this.requestCounter.push(e),this.requestCounter.length>this.rateLimit}async init(e){return this._transport.isResolved()?(await this.transport).type:(await this.setTransport(e),e.type)}async getOwnAppMetadata(){return{senderId:await B(await this.beaconId),name:this.name,icon:this.iconUrl}}async getPeers(){return(await this.transport).getPeers()}async addPeer(e){return(await this.transport).addPeer(e)}async destroy(){if(this._transport.isResolved()){const e=await this.transport;await this.cleanup(),await e.disconnect(),e.type===N.WALLETCONNECT&&await e.doClientCleanup()}await super.destroy()}async setTransport(e){e?this._transport.isSettled()?this._transport=P.resolve(e):this._transport.resolve(e):this._transport.isSettled()&&(this._transport=new P)}async addListener(e){this.transportListeners.has(e.type)&&await e.removeListener(this.transportListeners.get(e.type));const t=async(i,n)=>{if(typeof i=="string"){const a=await new F().deserialize(i);this.handleResponse(a,n)}};this.transportListeners.set(e.type,t),e.addListener(t).catch(i=>st.error("addListener",i))}async sendDisconnectToPeer(e,t){const i={id:await D(),version:e.version,senderId:await B(await this.beaconId),type:w.Disconnect},n=await new F().serialize(i);await(t??await this.transport).send(n,e)}}class nt{constructor(s){d(this,"storageManager");this.storageManager=new oe(s,h.APP_METADATA_LIST)}async getAppMetadataList(){return await this.storageManager.getAll()??[]}async getAppMetadata(s){return this.storageManager.getOne(e=>e.senderId===s)}async addAppMetadata(s){return this.storageManager.addOne(s,e=>e.senderId===s.senderId)}async removeAppMetadata(s){return this.storageManager.remove(e=>e.senderId===s)}async removeAppMetadatas(s){return this.storageManager.remove(e=>s.includes(e.senderId))}async removeAllAppMetadata(){return this.storageManager.removeAll()}}class at{constructor(s){d(this,"storage");this.storage=s}validateNumber(s){return typeof s=="number"&&!isNaN(s)}validateText(s){return typeof s=="string"}validateBoolean(s){return typeof s=="boolean"}validateArray(s){return Array.isArray(s)}objHasProperty(s,e){if(!s)return!1;const t=e.split(".");let i=s;for(const n of t){if(!i.hasOwnProperty(n))return!1;i=i[n]}return!0}innerValidate(s,e,t){if(!s)return!0;switch(e){case"num":return this.validateNumber(s);case"str":return this.validateText(s);case"bol":return this.validateBoolean(s);case"obj":return this.objHasProperty(s,t);case"arr":return this.validateArray(s);default:return!1}}async validate(){return!(!this.innerValidate(await this.storage.get(h.BEACON_SDK_VERSION),"str")||!this.innerValidate(await this.storage.get(h.MATRIX_SELECTED_NODE),"str")||!this.innerValidate(await this.storage.get(h.MULTI_NODE_SETUP_DONE),"bol")||!this.innerValidate(await this.storage.get(h.TRANSPORT_P2P_PEERS_DAPP),"arr")||!this.innerValidate(await this.storage.get(h.TRANSPORT_P2P_PEERS_WALLET),"arr")||!this.innerValidate(await this.storage.get(h.TRANSPORT_POSTMESSAGE_PEERS_DAPP),"arr")||!this.innerValidate(await this.storage.get(h.TRANSPORT_POSTMESSAGE_PEERS_WALLET),"arr")||!this.innerValidate(await this.storage.get(h.TRANSPORT_WALLETCONNECT_PEERS_DAPP),"arr")||!this.innerValidate(await this.storage.get(h.ACCOUNTS),"arr")||!this.innerValidate(await this.storage.get(h.APP_METADATA_LIST),"arr")||!this.innerValidate(await this.storage.get(h.PERMISSION_LIST),"arr")||!this.innerValidate(await this.storage.get(h.ACTIVE_ACCOUNT),"str")||!this.innerValidate(await this.storage.get(h.LAST_SELECTED_WALLET),"obj","key"))}}const K=new _("P2PTransport");class rt extends ce{constructor(e,t,i,n,a,r,o){super(e,new Te(e,t,1,i,n,r,o),new le(i,a));d(this,"type",N.P2P)}static async isAvailable(){return Promise.resolve(!0)}async connect(){if(this._isConnected!==v.NOT_CONNECTED)return;K.log("connect"),this._isConnected=v.CONNECTING,await this.client.start();const e=await this.getPeers();if(e.length>0){K.log("connect",`connecting to ${e.length} peers`);const t=e.map(async i=>this.listen(i.publicKey));Promise.all(t).catch(i=>K.error("connect",i))}return await this.startOpenChannelListener(),super.connect()}async disconnect(){return await this.client.stop(),super.disconnect()}async startOpenChannelListener(){}async getPairingRequestInfo(){return this.client.getPairingRequestInfo()}async listen(e){await this.client.listenForEncryptedMessage(e,t=>{const i={origin:T.P2P,id:e};this.notifyListeners(t,i).catch(n=>{throw n})}).catch(t=>{throw t})}}class ot{constructor(s){d(this,"rpcUrls");this.rpcUrls=s}async getLinkForNetwork(s){return this.rpcUrls[s.type]}}class ct extends ot{constructor(e={[m.MAINNET]:"https://tzkt.io",[m.GHOSTNET]:"https://ghostnet.tzkt.io",[m.WEEKLYNET]:"https://weeklynet.tzkt.io",[m.DAILYNET]:"https://dailynet.tzkt.io",[m.DELPHINET]:"https://delphinet.tzkt.io",[m.EDONET]:"https://edonet.tzkt.io",[m.FLORENCENET]:"https://florencenet.tzkt.io",[m.GRANADANET]:"https://granadanet.tzkt.io",[m.HANGZHOUNET]:"https://hangzhounet.tzkt.io",[m.ITHACANET]:"https://ithacanet.tzkt.io",[m.JAKARTANET]:"https://jakartanet.tzkt.io",[m.KATHMANDUNET]:"https://kathmandunet.tzkt.io",[m.LIMANET]:"https://limanet.tzkt.io",[m.MUMBAINET]:"https://mumbainet.tzkt.io",[m.NAIROBINET]:"https://nairobinet.tzkt.io",[m.OXFORDNET]:"https://oxfordnet.tzkt.io",[m.PARISNET]:"https://parisnet.tzkt.io",[m.CUSTOM]:"https://parisnet.tzkt.io"}){super(e);d(this,"rpcUrls");this.rpcUrls=e}async getAddressLink(e,t){return`${await this.getLinkForNetwork(t)}/${e}`}async getTransactionLink(e,t){return`${await this.getLinkForNetwork(t)}/${e}`}}const $=new _("DappPostMessageTransport");class lt extends de{constructor(s,e,t){super(s,e,t,h.TRANSPORT_POSTMESSAGE_PEERS_DAPP)}async startOpenChannelListener(){return this.client.listenForChannelOpening(async s=>{$.log("connect","received PostMessagePairingResponse",s),await this.addPeer(s),this._isConnected=v.CONNECTED,this.newPeerListener&&(this.newPeerListener(s),this.newPeerListener=void 0)})}async listenForNewPeer(s){$.log("listenForNewPeer"),this.newPeerListener=s}async stopListeningForNewPeers(){$.log("stopListeningForNewPeers"),this.newPeerListener=void 0}}const H=new _("DappP2PTransport");class dt extends rt{constructor(s,e,t,i,n,a){super(s,e,t,i,h.TRANSPORT_P2P_PEERS_DAPP,n,a)}async startOpenChannelListener(){return this.client.listenForChannelOpening(async s=>{H.log("listenForNewPeer","new publicKey",s.publicKey),await this.addPeer(s),this._isConnected=v.CONNECTED,this.newPeerListener&&(this.newPeerListener(s),this.newPeerListener=void 0)})}async listenForNewPeer(s){H.log("listenForNewPeer"),this.newPeerListener=s}async stopListeningForNewPeers(){H.log("stopListeningForNewPeers"),this.newPeerListener=void 0}}class S extends ce{constructor(e,t,i,n,a){super(e,Z.getInstance(a),new le(i,n));d(this,"wcOptions");d(this,"type",N.WALLETCONNECT);this.wcOptions=a}static async isAvailable(){return Promise.resolve(!0)}async connect(){if(this._isConnected!==v.NOT_CONNECTED)return;this._isConnected=v.CONNECTING,await this.client.init();const e=await this.getPeers();return e.length>0&&e.map(async t=>this.listen(t.publicKey)),await this.startOpenChannelListener(),super.connect()}wasDisconnectedByWallet(){return!!this.client.disconnectionEvents.size}async hasPairings(){return await this.client.storage.hasPairings()?!0:!!this.client.signClient?.pairing.getAll()?.length}async hasSessions(){return await this.client.storage.hasSessions()?!0:!!this.client.signClient?.session.getAll()?.length}forceUpdate(e){this.client.storage.notify(e)}async getPeers(){const t=Z.getInstance(this.wcOptions).currentSession();return t?[{senderId:t.peer.publicKey,extensionId:t.peer.metadata.name,id:t.peer.publicKey,type:"walletconnect-pairing-response",name:"peer",publicKey:t.peer.publicKey,version:"first"}]:[]}async disconnect(){return await this.client.close(),super.disconnect()}async startOpenChannelListener(){}async doClientCleanup(){await this.client.unsubscribeFromEncryptedMessages()}getPairingRequestInfo(){return this.client.getPairingRequestInfo()}async listen(e){await this.client.listenForEncryptedMessage(e,t=>{const i={origin:T.WALLETCONNECT,id:e};this.notifyListeners(t,i).catch(n=>{throw n})}).catch(t=>{throw t})}}const ht=new _("DappWalletConnectTransport");class pt extends S{constructor(s,e,t,i){super(s,e,t,h.TRANSPORT_WALLETCONNECT_PEERS_DAPP,i),this.client.listenForChannelOpening(async n=>{await this.addPeer(n),this._isConnected=v.CONNECTED,this.newPeerListener&&(this.newPeerListener(n),this.newPeerListener=void 0)})}async listenForNewPeer(s){this.newPeerListener=s}async stopListeningForNewPeers(){ht.log("stopListeningForNewPeers"),this.newPeerListener=void 0}}const c=new _("DAppClient");class ue extends it{constructor(e){super({storage:e&&e.storage?e.storage:new Ee,...e});d(this,"description");d(this,"blockExplorer");d(this,"enableAppSwitching");d(this,"enableMetrics");d(this,"userId");d(this,"network");d(this,"events",new ee);d(this,"postMessageTransport");d(this,"p2pTransport");d(this,"walletConnectTransport");d(this,"wcProjectId");d(this,"wcRelayUrl");d(this,"isGetActiveAccountHandled",!1);d(this,"openRequests",new Map);d(this,"_activeAccount",new P);d(this,"_activePeer",new P);d(this,"_initPromise");d(this,"isInitPending",!1);d(this,"activeAccountLoaded");d(this,"appMetadataManager");d(this,"disclaimerText");d(this,"errorMessages");d(this,"featuredWallets");d(this,"storageValidator");d(this,"bugReportStorage",new Pe("beacon","bug_report"));d(this,"debounceEventResponse",!1);d(this,"debounceSetActiveAccount",!1);d(this,"blockchains",new Map);this.description=e.description,this.wcProjectId=e.walletConnectOptions?.projectId||"24469fd0a06df227b6e5f7dc7de0ff4f",this.wcRelayUrl=e.walletConnectOptions?.relayUrl,this.featuredWallets=e.featuredWallets,this.events=new ee(e.eventHandlers,e.disableDefaultEvents??!1),this.blockExplorer=e.blockExplorer??new ct,this.network=e.network??{type:e.preferredNetwork??m.MAINNET},te(e.colorMode??ve.LIGHT),this.disclaimerText=e.disclaimerText,this.errorMessages=e.errorMessages??{},this.appMetadataManager=new nt(this.storage),this.storageValidator=new at(this.storage),this.enableAppSwitching=e.enableAppSwitching===void 0?!0:!!e.enableAppSwitching,this.enableMetrics=!!e.enableMetrics,this.storage.subscribeToStorageChanged(async t=>{if(t.eventType==="storageCleared")this.setActiveAccount(void 0);else if(t.eventType==="entryModified")if(t.key===this.storage.getPrefixedKey(h.ACTIVE_ACCOUNT)){const i=t.newValue;if(!i||i==="undefined")this.setActiveAccount(void 0);else{const n=await this.getAccount(i);this.setActiveAccount(n)}}else t.key===this.storage.getPrefixedKey(h.ENABLE_METRICS)&&(this.enableMetrics=!!await this.storage.get(h.ENABLE_METRICS))}),this.activeAccountLoaded=this.storage.get(h.ACTIVE_ACCOUNT).then(async t=>{if(t){const i=await this.accountManager.getAccount(t);return await this.setActiveAccount(i),i}else{await this.setActiveAccount(void 0);return}}).catch(async t=>{await this.setActiveAccount(void 0),c.error(t)}),this.handleResponse=async(t,i)=>{const n=this.openRequests.get(t.id);if(c.log("### openRequest ###",n),c.log("handleResponse","Received message",t,i),c.log("### message ###",JSON.stringify(t)),c.log("### connectionInfo ###",i),t.version==="3"){const a=t;if(n&&a.message?.type===w.Acknowledge)this.analytics.track("event","DAppClient","Acknowledge received from Wallet"),c.log("handleResponse",`acknowledge message received for ${t.id}`),this.events.emit(f.ACKNOWLEDGE_RECEIVED,{message:a.message,extraInfo:{},walletInfo:await this.getWalletInfo()}).catch(console.error);else if(n){const r=a.message.blockchainData.appMetadata;a.message?.type===w.PermissionResponse&&r&&await this.appMetadataManager.addAppMetadata(r),a.message?.type===w.Error?n.reject(a.message):n.resolve({message:t,connectionInfo:i}),this.openRequests.delete(a.id)}else if(a.message?.type===w.Disconnect){this.analytics.track("event","DAppClient","Disconnect received from Wallet");const r=i.origin===T.P2P?this.p2pTransport:i.origin===T.WALLETCONNECT?this.walletConnectTransport:this.postMessageTransport??await this.transport;if(r){const l=(await r.getPeers()).find(p=>p.senderId===t.senderId);l&&await r.removePeer(l),await this.removeAccountsForPeerIds([t.senderId]),await this.events.emit(f.CHANNEL_CLOSED)}}else a.message?.type===w.ChangeAccountRequest?await this.onNewAccount(a.message,i):c.error("handleResponse","no request found for id ",t.id,t)}else{const a=t;if(n&&a.type===w.Acknowledge)c.log("handleResponse",`acknowledge message received for ${t.id}`),this.analytics.track("event","DAppClient","Acknowledge received from Wallet"),this.events.emit(f.ACKNOWLEDGE_RECEIVED,{message:a,extraInfo:{},walletInfo:await this.getWalletInfo()}).catch(console.error);else if(n)a.type===w.PermissionResponse&&a.appMetadata&&await this.appMetadataManager.addAppMetadata(a.appMetadata),a.type===w.Error||t.errorType?n.reject(a):n.resolve({message:t,connectionInfo:i}),this.openRequests.delete(a.id);else if(a.type===w.Disconnect||t?.typedMessage?.type===w.Disconnect){this.analytics.track("event","DAppClient","Disconnect received from Wallet");const r=i.origin===T.P2P?this.p2pTransport:i.origin===T.WALLETCONNECT?this.walletConnectTransport:this.postMessageTransport??await this.transport;if(r){const l=(await r.getPeers()).find(p=>p.senderId===t.senderId);l&&await r.removePeer(l),await this.removeAccountsForPeerIds([t.senderId]),await this.events.emit(f.CHANNEL_CLOSED)}}else a.type===w.ChangeAccountRequest?this.debounceEventResponse||(this.debounceEventResponse=!0,await this.onNewAccount(a,i),this.debounceEventResponse=!1):c.error("handleResponse","no request found for id ",t.id,t)}this._transport.isResolved()&&await this.transport instanceof S&&!this.openRequests.has("session_update")&&this.openRequests.set("session_update",new P)},this.storageValidator.validate().then(async t=>{const i=await this.activeAccountLoaded;if(!t){const n=await this.getWalletInfo(void 0,i,!1);n.type=n.type==="extension"&&i?.origin.type===T.P2P?"mobile":n.type,await this.storage.set(h.LAST_SELECTED_WALLET,{icon:n.icon??"",key:n.name,type:n.type??"web",name:n.name,url:n.deeplink}),await this.storageValidator.validate()||this.resetInvalidState(!1)}i&&i.origin.type!=="p2p"&&this.init()}).catch(t=>c.error(t.message)),this.sendMetrics("enable-metrics?"+this.addQueryParam("version",G),void 0,t=>{t.ok||(t.status===426?console.error("Metrics are no longer supported for this version, please upgrade."):console.warn("Network error encountered. Metrics sharing have been automatically disabled.")),this.enableMetrics=t.ok,this.storage.set(h.ENABLE_METRICS,t.ok)},()=>{this.enableMetrics=!1,this.storage.set(h.ENABLE_METRICS,!1)}),this.initUserID().catch(t=>c.error(t.message))}async createStateSnapshot(){if(!localStorage||!this.enableMetrics)return;const e=Object.values(h).filter(t=>!t.includes("wc@2")&&!t.includes("secret")&&!t.includes("account"));try{for(const t of e)await this.bugReportStorage.set(t,await this.storage.get(t))}catch(t){c.error("createStateSnapshot",t.message)}}async initUserID(){const e=await this.storage.get(h.USER_ID);if(e){this.userId=e;return}this.userId=await D(),this.storage.set(h.USER_ID,this.userId)}async initInternalTransports(){const e=await this.keyPair;if(this.postMessageTransport||this.p2pTransport||this.walletConnectTransport)return;this.postMessageTransport=new lt(this.name,e,this.storage),await this.addListener(this.postMessageTransport),this.p2pTransport=new dt(this.name,e,this.storage,this.matrixNodes,this.iconUrl,this.appUrl),await this.addListener(this.p2pTransport);const t={projectId:this.wcProjectId,relayUrl:this.wcRelayUrl,metadata:{name:this.name,description:this.description??"",url:this.appUrl??"",icons:this.iconUrl?[this.iconUrl]:[]}};this.walletConnectTransport=new pt(this.name,e,this.storage,{network:this.network.type,opts:t}),this.initEvents(),await this.addListener(this.walletConnectTransport)}initEvents(){this.walletConnectTransport&&(this.walletConnectTransport.setEventHandler("CLOSE_ALERT",this.hideUI.bind(this,["alert","toast"])),this.walletConnectTransport.setEventHandler("RESET_STATE",this.channelClosedHandler.bind(this)),this.walletConnectTransport.setEventHandler("WC_ACK_NOTIFICATION",this.wcToastHandler.bind(this)))}async wcToastHandler(e){const t=await(async()=>{try{return await this.getWalletInfo()}catch{return{name:"wallet"}}})();await this.events.emit(f.HIDE_UI,["alert"]),e==="pending"?this.events.emit(f.ACKNOWLEDGE_RECEIVED,{message:{},extraInfo:{},walletInfo:t}):this.events.emit(f.PERMISSION_REQUEST_ERROR,{errorResponse:{errorType:C.ABORTED_ERROR},walletInfo:t})}async channelClosedHandler(e){(await this.transport).type===e&&(await this.events.emit(f.CHANNEL_CLOSED),this.setActiveAccount(void 0),await this.disconnect())}async destroy(){await this.createStateSnapshot(),await super.destroy()}async init(e){if(this._initPromise)return this._initPromise;try{await this.activeAccountLoaded}catch{}return this._initPromise=new Promise(async t=>{if(e)await this.addListener(e),t(await super.init(e));else if(this._transport.isSettled())await(await this.transport).connect(),t(await super.init(await this.transport));else{const i=await this.getActiveAccount(),n=()=>{this.postMessageTransport&&this.postMessageTransport.stopListeningForNewPeers().catch(console.error),this.p2pTransport&&this.p2pTransport.stopListeningForNewPeers().catch(console.error),this.walletConnectTransport&&this.walletConnectTransport.stopListeningForNewPeers().catch(console.error)};if(await this.initInternalTransports(),!this.postMessageTransport||!this.p2pTransport||!this.walletConnectTransport)return;if(this.postMessageTransport.connect().then().catch(console.error),i&&i.origin){const a=i.origin.type;a===T.EXTENSION?t(await super.init(this.postMessageTransport)):a===T.P2P?t(await super.init(this.p2pTransport)):a===T.WALLETCONNECT&&t(await super.init(this.walletConnectTransport))}else{const a=this.p2pTransport,r=this.postMessageTransport,o=this.walletConnectTransport;r.listenForNewPeer(l=>{c.log("init","postmessage transport peer connected",l),this.analytics.track("event","DAppClient","Extension connected",{peerName:l.name}),this.events.emit(f.PAIR_SUCCESS,l).catch(p=>console.warn(p)),this.setActivePeer(l).catch(console.error),this.setTransport(this.postMessageTransport).catch(console.error),n(),t(N.POST_MESSAGE)}).catch(console.error),a.listenForNewPeer(l=>{c.log("init","p2p transport peer connected",l),this.analytics.track("event","DAppClient","Beacon Wallet connected",{peerName:l.name}),this.events.emit(f.PAIR_SUCCESS,l).catch(p=>console.warn(p)),this.setActivePeer(l).catch(console.error),this.setTransport(this.p2pTransport).catch(console.error),n(),t(N.P2P)}).catch(console.error),o.listenForNewPeer(l=>{c.log("init","walletconnect transport peer connected",l),this.analytics.track("event","DAppClient","WalletConnect Wallet connected",{peerName:l.name}),this.events.emit(f.PAIR_SUCCESS,l).catch(p=>console.warn(p)),this.setActivePeer(l).catch(console.error),this.setTransport(this.walletConnectTransport).catch(console.error),n(),t(N.WALLETCONNECT)}).catch(console.error),de.getAvailableExtensions().then(async l=>{this.analytics.track("event","DAppClient","Extensions detected",{extensions:l})}).catch(l=>{this._initPromise=void 0,console.error(l)}),this.events.emit(f.PAIR_INIT,{p2pPeerInfo:()=>(a.connect().then().catch(console.error),a.getPairingRequestInfo()),postmessagePeerInfo:()=>r.getPairingRequestInfo(),walletConnectPeerInfo:()=>o.getPairingRequestInfo(),networkType:this.network.type,abortedHandler:async()=>{c.log("init","ABORTED"),this.sendMetrics("performance-metrics/save",await this.buildPayload("connect","abort")),await Promise.all([r.disconnect(),o.disconnect()]),this.postMessageTransport=this.walletConnectTransport=this.p2pTransport=void 0,this._activeAccount.isResolved()&&this.clearActiveAccount(),this._initPromise=void 0},disclaimerText:this.disclaimerText,analytics:this.analytics,featuredWallets:this.featuredWallets}).catch(l=>console.warn(l))}}}),this._initPromise}async getActiveAccount(){return this._activeAccount.promise}async isInvalidState(e){const t=await this._activeAccount.promise;return t?t?.address!==e?.address&&!this.isGetActiveAccountHandled:!1}async resetInvalidState(e=!0){this.accountManager.removeAllAccounts(),this._activeAccount=P.resolve(void 0),this.storage.set(h.ACTIVE_ACCOUNT,void 0),e&&this.events.emit(f.INVALID_ACTIVE_ACCOUNT_STATE),!e&&this.hideUI(["alert"]),await Promise.all([this.postMessageTransport?.disconnect(),this.walletConnectTransport?.disconnect()]),this.postMessageTransport=this.p2pTransport=this.walletConnectTransport=void 0,await this.setActivePeer(void 0),await this.setTransport(void 0),this._initPromise=void 0}async setActiveAccount(e){if(this.isGetActiveAccountHandled||console.warn(`An active account has been received, but no active subscription was found for BeaconEvent.ACTIVE_ACCOUNT_SET.
        For more information, visit: https://docs.walletbeacon.io/guides/migration-guide`),e&&this._activeAccount.isSettled()&&await this.isInvalidState(e)){const t=await this.transport;if(t instanceof S&&t.wasDisconnectedByWallet()){await this.resetInvalidState();return}}if(!e&&this._activeAccount.isResolved()&&await this.getActiveAccount()){const t=await this.transport,i=await this.getActiveAccount();if(!t||!i)return;!this.debounceSetActiveAccount&&t instanceof S&&(this.debounceSetActiveAccount=!0,this._initPromise=void 0,this.postMessageTransport=this.p2pTransport=this.walletConnectTransport=void 0,await t.disconnect(),this.debounceSetActiveAccount=!1)}if(this._activeAccount.isSettled()?this._activeAccount=P.resolve(e):this._activeAccount.resolve(e),!this.isGetActiveAccountHandled&&this._transport.isResolved()){const t=await this.transport;if(t instanceof S&&t.wasDisconnectedByWallet()){await this.resetInvalidState();return}}if(e){const t=e.origin.type;if(await this.initInternalTransports(),t===T.EXTENSION?await this.setTransport(this.postMessageTransport):t===T.P2P?await this.setTransport(this.p2pTransport):t===T.WALLETCONNECT&&(await this.setTransport(this.walletConnectTransport),this.walletConnectTransport?.forceUpdate("INIT")),this._transport.isResolved()){const n=await this.transport;n.connectionStatus===v.NOT_CONNECTED&&await n.connect()}const i=await this.getPeer(e);await this.setActivePeer(i)}else await this.setActivePeer(void 0),await this.setTransport(void 0);await this.storage.set(h.ACTIVE_ACCOUNT,e?e.accountIdentifier:void 0),await this.events.emit(f.ACTIVE_ACCOUNT_SET,e)}clearActiveAccount(){return this.setActiveAccount()}async setColorMode(e){return te(e)}async getColorMode(){return Ie()}async getAppMetadata(){return this.getOwnAppMetadata()}async showPrepare(){const e=await(async()=>{try{return await this.getWalletInfo()}catch{return}})();await this.events.emit(f.SHOW_PREPARE,{walletInfo:e})}async hideUI(e){await this.events.emit(f.HIDE_UI,e)}async tryToAppSwitch(){if(!Ce(window)||!this.enableAppSwitching)return;const e=await this.getWalletInfo();if(e.type!=="mobile"||!e.deeplink)return;const t=Re(window)?e.deeplink:`${e.deeplink}wc?uri=`;t?.length&&(window.location=t)}addQueryParam(e,t){return e+"="+t}async buildPayload(e,t){const i=await this.storage.get(h.LAST_SELECTED_WALLET),n=this._activeAccount.isResolved()?(await this.getActiveAccount())?.origin.type??"UNKOWN":"UNKOWN";return{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({userId:this.userId,os:be(),walletName:i?.name??"init",walletType:i?.type??"init",sdkVersion:G,transport:n,time:new Date,action:e,status:t})}}sendMetrics(e,t,i,n){this.enableMetrics&&fetch(`https://beacon-backend.prod.gke.papers.tech/${e}`,t).then(a=>i&&i(a)).catch(a=>{console.warn("Network error encountered. Metrics sharing have been automatically disabled."),c.error(a.message),this.enableMetrics=!1,n&&n(a)})}async removeAccount(e){const t=super.removeAccount(e),i=await this.getActiveAccount();return i&&i.accountIdentifier===e&&await this.setActiveAccount(void 0),t}async removeAllAccounts(){await super.removeAllAccounts(),await this.setActiveAccount(void 0)}async removePeer(e,t=!1){const i=await this.transport,n=i.removePeer(e);return await this.removeAccountsForPeers([e]),t&&await this.sendDisconnectToPeer(e,i),n}async removeAllPeers(e=!1){const t=await this.transport,i=await t.getPeers(),n=t.removeAllPeers();if(await this.removeAccountsForPeers(i),e){const a=i.map(r=>this.sendDisconnectToPeer(r,t));await Promise.all(a)}return n}async subscribeToEvent(e,t){e===f.ACTIVE_ACCOUNT_SET&&(this.isGetActiveAccountHandled=!0),await this.events.on(e,t)}async checkPermissions(e){if([w.PermissionRequest,w.ProofOfEventChallengeRequest,w.SimulatedProofOfEventChallengeRequest].includes(e))return!0;const t=await this.getActiveAccount();if(!t)throw await this.sendInternalError("No active account set!");const i=t.scopes;switch(e){case w.OperationRequest:return i.includes(R.OPERATION_REQUEST);case w.SignPayloadRequest:return i.includes(R.SIGN);case w.BroadcastRequest:return!0;default:return!1}}async sendNotification(e,t,i,n){const a=await this.getActiveAccount();if(!a||a&&!a.scopes.includes(R.NOTIFICATION)&&!a.notification)throw new Error("notification permissions not given");if(!a.notification?.token)throw new Error("No AccessToken");const r=a.notification?.apiUrl;if(!r)throw new Error("No Push URL set");return this.sendNotificationWithAccessToken({url:r,recipient:a.address,title:e,body:t,payload:i,protocolIdentifier:n,accessToken:a.notification?.token})}addBlockchain(e){this.blockchains.set(e.identifier,e),e.getWalletLists().then(t=>{Se(t.desktopList),Ne(t.extensionList),_e(t.webList),ke(t.iOSList)})}removeBlockchain(e){this.blockchains.delete(e)}async permissionRequest(e){c.log("permissionRequest",e);const t=this.blockchains.get(e.blockchainIdentifier);if(!t)throw new Error(`Blockchain "${e.blockchainIdentifier}" not supported by dAppClient`);const i={...e,type:w.PermissionRequest,blockchainData:{...e.blockchainData,appMetadata:await this.getOwnAppMetadata()}};c.log("REQUESTION PERMIMISSION V3","xxx",i),this.sendMetrics("performance-metrics/save",await this.buildPayload("connect","start"));const n=`makeRequestV3 ${Date.now()}`;c.time(!0,n);const{message:a,connectionInfo:r}=await this.makeRequestV3(i).catch(async p=>{throw p.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),c.time(!1,n),new Error("TODO")});c.time(!1,n),this.sendMetrics("performance-metrics/save",await this.buildPayload("connect","start")),c.log("RESPONSE V3",a,r);const o=await t.getAccountInfosFromPermissionResponse(a.message),l={accountIdentifier:o[0].accountId,senderId:a.senderId,origin:{type:r.origin,id:r.id},address:o[0].address,publicKey:o[0].publicKey,scopes:a.message.blockchainData.scopes,connectedAt:new Date().getTime(),chainData:a.message.blockchainData};return await this.accountManager.addAccount(l),await this.setActiveAccount(l),await t.handleResponse({request:i,account:l,output:a,blockExplorer:this.blockExplorer,connectionContext:r,walletInfo:await this.getWalletInfo()}),await this.notifySuccess(i,{account:l,output:{address:o[0].address,network:{type:m.MAINNET},scopes:[R.OPERATION_REQUEST]},blockExplorer:this.blockExplorer,connectionContext:r,walletInfo:await this.getWalletInfo()}),a.message}async request(e){c.log("request",e);const t=this.blockchains.get(e.blockchainIdentifier);if(!t)throw new Error(`Blockchain "${t}" not supported by dAppClient`);await t.validateRequest(e);const i=await this.getActiveAccount();if(!i)throw await this.sendInternalError("No active account!");const n={...e,type:w.BlockchainRequest,accountId:i.accountIdentifier};this.sendMetrics("performance-metrics/save",await this.buildPayload("message","start"));const a=`makeRequestV3 ${Date.now()}`;c.time(!0,a);const{message:r,connectionInfo:o}=await this.makeRequestV3(n).catch(async l=>{throw console.error(l),l.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),c.time(!1,a),new Error("TODO")});return c.time(!1,a),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","success")),await t.handleResponse({request:n,account:i,output:r,blockExplorer:this.blockExplorer,connectionContext:o,walletInfo:await this.getWalletInfo()}),r.message}async requestPermissions(e){e?.network!==void 0&&this.network.type!==e?.network?.type&&console.error("[BEACON] The network specified in the DAppClient constructor does not match the network set in the permission request. Please set the network in the constructor. Setting it during the Permission Request is deprecated.");const t={appMetadata:await this.getOwnAppMetadata(),type:w.PermissionRequest,network:this.network,scopes:e&&e.scopes?e.scopes:[R.OPERATION_REQUEST,R.SIGN]};this.analytics.track("event","DAppClient","Permission requested"),this.sendMetrics("performance-metrics/save",await this.buildPayload("connect","start"));const i=`makeRequest ${Date.now()}`;c.time(!0,i);const{message:n,connectionInfo:a}=await this.makeRequest(t).catch(async l=>{throw l.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),c.time(!1,i),await this.handleRequestError(t,l)});c.time(!1,i),this.sendMetrics("performance-metrics/save",await this.buildPayload("connect","success")),c.log("requestPermissions","######## MESSAGE #######"),c.log("requestPermissions",n);const r=await this.onNewAccount(n,a);c.log("requestPermissions","######## ACCOUNT INFO #######"),c.log("requestPermissions",JSON.stringify(r)),await this.accountManager.addAccount(r);const o={...n,walletKey:r.walletKey,address:r.address,accountInfo:r};return await this.notifySuccess(t,{account:r,output:o,blockExplorer:this.blockExplorer,connectionContext:a,walletInfo:await this.getWalletInfo()}),this.analytics.track("event","DAppClient","Permission received",{address:r.address}),o}async requestProofOfEventChallenge(e){const t=await this.getActiveAccount();if(!t)throw new Error("Please request permissions before doing a proof of event challenge");if(t.walletType!=="abstracted_account"&&t.verificationType!=="proof_of_event")throw new Error("This wallet is not an abstracted account and thus cannot perform proof of event");const i={type:w.ProofOfEventChallengeRequest,contractAddress:t.address,payload:e.payload};this.sendMetrics("performance-metrics/save",await this.buildPayload("message","start"));const n=`makeRequest ${Date.now()}`;c.time(!0,n);const{message:a,connectionInfo:r}=await this.makeRequest(i).catch(async o=>{throw o.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),c.time(!1,n),await this.handleRequestError(i,o)});return c.time(!1,n),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","success")),this.analytics.track("event","DAppClient",`Proof of event challenge ${a.isAccepted?"accepted":"refused"}`,{address:t.address}),await this.notifySuccess(i,{account:t,output:a,blockExplorer:this.blockExplorer,connectionContext:r,walletInfo:await this.getWalletInfo()}),a}async requestSimulatedProofOfEventChallenge(e){const t=await this.getActiveAccount();if(!t)throw new Error("Please request permissions before doing a proof of event challenge");if(t.walletType!=="abstracted_account"&&t.verificationType!=="proof_of_event")throw new Error("This wallet is not an abstracted account and thus cannot perform a simulated proof of event");const i={type:w.SimulatedProofOfEventChallengeRequest,contractAddress:t.address,...e},n=`makeRequest ${Date.now()}`;c.time(!0,n);const{message:a,connectionInfo:r}=await this.makeRequest(i).catch(async o=>{throw c.time(!1,n),await this.handleRequestError(i,o)});return c.time(!1,n),this.analytics.track("event","DAppClient",`Simulated proof of event challenge ${a.errorMessage?"refused":"accepted"}`,{address:t.address}),await this.notifySuccess(i,{account:t,output:a,blockExplorer:this.blockExplorer,connectionContext:r,walletInfo:await this.getWalletInfo()}),a}async requestSignPayload(e){if(!e.payload)throw await this.sendInternalError("Payload must be provided");const t=await this.getActiveAccount();if(!t)throw await this.sendInternalError("No active account!");const i=e.payload;if(typeof i!="string")throw new Error("Payload must be a string");const n=(()=>{switch(e.signingType){case E.OPERATION:if(!i.startsWith("03"))throw new Error('When using signing type "OPERATION", the payload must start with prefix "03"');return E.OPERATION;case E.MICHELINE:if(!i.startsWith("05"))throw new Error('When using signing type "MICHELINE", the payload must start with prefix "05"');return E.MICHELINE;case E.RAW:default:return E.RAW}})();this.analytics.track("event","DAppClient","Signature requested");const a={type:w.SignPayloadRequest,signingType:n,payload:i,sourceAddress:e.sourceAddress||t.address};this.sendMetrics("performance-metrics/save",await this.buildPayload("message","start"));const r=`makeRequest ${Date.now()}`;c.time(!0,r);const{message:o,connectionInfo:l}=await this.makeRequest(a).catch(async p=>{throw p.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),c.time(!1,r),await this.handleRequestError(a,p)});return c.time(!1,r),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","success")),await this.notifySuccess(a,{account:t,output:o,connectionContext:l,walletInfo:await this.getWalletInfo()}),this.analytics.track("event","DAppClient","Signature response"),o}async requestOperation(e){if(!e.operationDetails)throw await this.sendInternalError("Operation details must be provided");const t=await this.getActiveAccount();if(!t)throw await this.sendInternalError("No active account!");const i={type:w.OperationRequest,network:t.network||this.network,operationDetails:e.operationDetails,sourceAddress:t.address||""};this.analytics.track("event","DAppClient","Operation requested"),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","start"));const n=`makeRequest ${Date.now()}`;c.time(!0,n);const{message:a,connectionInfo:r}=await this.makeRequest(i).catch(async o=>{throw o.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),c.time(!1,n),await this.handleRequestError(i,o)});return c.time(!1,n),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","success")),await this.notifySuccess(i,{account:t,output:a,blockExplorer:this.blockExplorer,connectionContext:r,walletInfo:await this.getWalletInfo()}),this.analytics.track("event","DAppClient","Operation response"),a}async requestBroadcast(e){if(!e.signedTransaction)throw await this.sendInternalError("Signed transaction must be provided");e.network!==void 0&&this.network.type!==e.network?.type&&console.error("[BEACON] The network specified in the DAppClient constructor does not match the network set in the broadcast request. Please set the network in the constructor. Setting it during the Broadcast Request is deprecated.");const t={type:w.BroadcastRequest,network:this.network,signedTransaction:e.signedTransaction};this.analytics.track("event","DAppClient","Broadcast requested"),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","start"));const i=`makeRequest ${Date.now()}`;c.time(!0,i);const{message:n,connectionInfo:a}=await this.makeRequest(t).catch(async r=>{throw r.errorType===C.ABORTED_ERROR?this.sendMetrics("performance-metrics/save",await this.buildPayload("message","abort")):this.sendMetrics("performance-metrics/save",await this.buildPayload("message","error")),c.time(!1,i),await this.handleRequestError(t,r)});return c.time(!1,i),this.sendMetrics("performance-metrics/save",await this.buildPayload("message","success")),await this.notifySuccess(t,{network:this.network,output:n,blockExplorer:this.blockExplorer,connectionContext:a,walletInfo:await this.getWalletInfo()}),this.analytics.track("event","DAppClient","Broadcast response"),n}async setActivePeer(e){this._activePeer.isSettled()?this._activePeer=P.resolve(e):this._activePeer.resolve(e),e&&(await this.initInternalTransports(),e.type==="postmessage-pairing-response"?await this.setTransport(this.postMessageTransport):e.type==="p2p-pairing-response"&&await this.setTransport(this.p2pTransport))}async setTransport(e){e||(this._initPromise=void 0);const t=super.setTransport(e),i=e?{...e}:void 0;return i&&(i.client={...i.client,keyPair:void 0}),await this.events.emit(f.ACTIVE_TRANSPORT_SET,i),t}async sendInternalError(e){throw await this.events.emit(f.INTERNAL_ERROR,{text:e}),new Error(e)}async removeAccountsForPeers(e){const t=e.map(i=>i.senderId);return this.removeAccountsForPeerIds(t)}async removeAccountsForPeerIds(e){const n=(await this.accountManager.getAccounts()).filter(r=>e.includes(r.senderId)).map(r=>r.accountIdentifier);await this.accountManager.removeAccounts(n);const a=await this.getActiveAccount();a&&n.includes(a.accountIdentifier)&&await this.setActiveAccount(void 0)}async handleRequestError(e,t){if(c.error("handleRequestError","error response",t),t.errorType){const i=[];if(t.errorType===C.NO_PRIVATE_KEY_FOUND_ERROR){const r=async()=>{const o=e;let l;if(o.sourceAddress&&o.network){const p=await j(o.sourceAddress,o.network);l=await this.getAccount(p),l&&await this.removeAccount(l.accountIdentifier)}};i.push({text:"Remove account",actionCallback:r})}const n=await this.getPeer(),a=await this.getActiveAccount();throw e.type===w.PermissionRequest&&await this.getActiveAccount()===void 0&&(this._initPromise=void 0,this.postMessageTransport=void 0,this.p2pTransport=void 0,this.walletConnectTransport=void 0,await this.setTransport(),await this.setActivePeer()),this.events.emit(W[e.type].error,{errorResponse:t,walletInfo:await this.getWalletInfo(n,a),errorMessages:this.errorMessages},i).catch(r=>c.error("handleRequestError",r)),Oe.getError(t.errorType,t.errorData)}throw t}async notifySuccess(e,t){this.events.emit(W[e.type].success,t).catch(i=>console.warn(i))}async getWalletInfoFromStorage(){return await this.storage.get(h.LAST_SELECTED_WALLET)}async updateStorageWallet(e){const t=await this.storage.get(h.LAST_SELECTED_WALLET);t&&(t.name=e.name,t.icon=e.icon??t.icon,this.storage.set(h.LAST_SELECTED_WALLET,t))}async getWalletInfo(e,t,i=!0){const n=t||await this.getActiveAccount(),a=e||await this.getPeer(n);let r;n&&(r=await this.appMetadataManager.getAppMetadata(n.senderId));let o;i&&(o=await this.getWalletInfoFromStorage()),r||(r={name:a?.name??o?.key??"",icon:a?.icon??o?.icon,type:o?.type},this.updateStorageWallet(r));const l=(y,X)=>y&&X?y.toLowerCase()===X.toLowerCase():!1,p=y=>y.split(/[_\s]+/)[0],g=[...Me(),...Le(),...De(),...qe()].filter(y=>l(p(y.key),p(r?.name??"wallet"))),k=g.find(y=>y.universalLink||y.key.includes("ios")||y.key.includes("mobile")),O=g.find(y=>y.links),M=g.find(y=>y.downloadLink),L=g.find(y=>y.id),q={extension:{app:L,type:"extension"},desktop:{app:M,type:"desktop"},mobile:{app:k,type:"mobile"},web:{app:O,type:"web"}},V=()=>ne(window)&&O?{app:O,type:"web"}:Ve(window)&&M?{app:M,type:"desktop"}:ne(window)&&L?{app:L,type:"extension"}:k?{app:k,type:"mobile"}:{app:void 0,type:void 0},{app:I,type:J}=o?q[o.type]:V();if(I){let y;return I.hasOwnProperty("links")?y=I.links[n?.network.type??this.network.type]:I.hasOwnProperty("deepLink")&&(y=I.deepLink),{name:I?.name??r.name,icon:I?.logo??r.icon,deeplink:y,type:J}}return r}async getPeer(e){let t;if(e){c.log("getPeer","We have an account",e);const i=await this.postMessageTransport?.getPeers()??[],n=await this.p2pTransport?.getPeers()??[],a=await this.walletConnectTransport?.getPeers()??[],r=[...i,...n,...a];c.log("getPeer","Found peers",r,e),t=r.find(o=>o.senderId===e.senderId),t||(t=r.find(o=>o.extensionId===e.origin.id))}else t=await this._activePeer.promise,c.log("getPeer","Active peer",t);return t}async makeRequest(e,t){const i=await D();if(this._initPromise&&this.isInitPending&&(await Promise.all([this.postMessageTransport?.disconnect(),this.walletConnectTransport?.disconnect()]),this._initPromise=void 0,this.hideUI(["toast"])),c.log("makeRequest","starting"),this.isInitPending=!0,await this.init(),this.isInitPending=!1,c.log("makeRequest","after init"),await this.addRequestAndCheckIfRateLimited())throw this.events.emit(f.LOCAL_RATE_LIMIT_REACHED).catch(g=>console.warn(g)),new Error("rate limit reached");if(!await this.checkPermissions(e.type))throw this.events.emit(f.NO_PERMISSIONS).catch(g=>console.warn(g)),new Error("No permissions to send this request to wallet!");if(!this.beaconId)throw await this.sendInternalError("BeaconID not defined");const n={id:i,version:"2",senderId:await B(await this.beaconId),...e};let a;t||(a=new P,this.addOpenRequest(n.id,a));const r=await new F().serialize(n),o=await this.getActiveAccount(),l=await this.getPeer(o),p=await this.getWalletInfo(l,o);c.log("makeRequest","sending message",n);try{(await this.transport).send(r,l),(n.type!==w.PermissionRequest||this._activeAccount.isResolved()&&await this._activeAccount.promise)&&this.tryToAppSwitch()}catch(g){throw this.events.emit(f.INTERNAL_ERROR,{text:"Unable to send message. If this problem persists, please reset the connection and pair your wallet again.",buttons:[{text:"Reset Connection",actionCallback:async()=>{await se(),this.disconnect()}}]}),g}return this.events.emit(W[e.type].sent,{walletInfo:{...p,name:p.name??"Wallet"},extraInfo:{resetCallback:async()=>{this.disconnect()}}}).catch(g=>console.warn(g)),a?.promise}async makeRequestV3(e){this._initPromise&&this.isInitPending&&(await Promise.all([this.postMessageTransport?.disconnect(),this.walletConnectTransport?.disconnect()]),this._initPromise=void 0,this.hideUI(["toast"]));const t=await D();if(c.log("makeRequest","starting"),this.isInitPending=!0,await this.init(),this.isInitPending=!1,c.log("makeRequest","after init"),await this.addRequestAndCheckIfRateLimited())throw this.events.emit(f.LOCAL_RATE_LIMIT_REACHED).catch(g=>console.warn(g)),new Error("rate limit reached");if(!this.beaconId)throw await this.sendInternalError("BeaconID not defined");const i={id:t,version:"3",senderId:await B(await this.beaconId),message:e},n=new P;this.addOpenRequest(i.id,n);const a=await new F().serialize(i),r=await this.getActiveAccount(),o=await this.getPeer(r),l=await this.getWalletInfo(o,r);c.log("makeRequest","sending message",i);try{(await this.transport).send(a,o),(i.message.type!==w.PermissionRequest||this._activeAccount.isResolved()&&await this._activeAccount.promise)&&this.tryToAppSwitch()}catch(g){throw this.events.emit(f.INTERNAL_ERROR,{text:"Unable to send message. If this problem persists, please reset the connection and pair your wallet again.",buttons:[{text:"Reset Connection",actionCallback:async()=>{await se(),this.disconnect()}}]}),g}const p=e.type;return this.events.emit(W[p].sent,{walletInfo:{...l,name:l.name??"Wallet"},extraInfo:{resetCallback:async()=>{this.disconnect()}}}).catch(g=>console.warn(g)),n.promise}async disconnect(){if(!this._transport.isResolved())throw new Error("No transport available.");const e=await this.transport;if(e.connectionStatus===v.NOT_CONNECTED)throw new Error("Not connected.");await this.createStateSnapshot(),this.sendMetrics("performance-metrics/save",await this.buildPayload("disconnect","start")),await this.clearActiveAccount(),e instanceof S||await e.disconnect(),this.postMessageTransport=void 0,this.p2pTransport=void 0,this.walletConnectTransport=void 0,this.sendMetrics("performance-metrics/save",await this.buildPayload("disconnect","success"))}addOpenRequest(e,t){c.log("addOpenRequest",this.name,`adding request ${e} and waiting for answer`),this.openRequests.set(e,t)}async sendNotificationWithAccessToken(e){const{url:t,recipient:i,title:n,body:a,payload:r,protocolIdentifier:o,accessToken:l}=e,p=new Date().toISOString(),g=await this.keyPair,k=g.publicKey,O=Buffer.from(new Uint8Array([13,15,37,217])),M=xe.encode(Buffer.concat([O,Buffer.from(k)])),L=["Tezos Signed Message: ",i,n,a,p,r].join(" "),q=re(L),V="0501"+q.length.toString(16).padStart(8,"0")+q,I=await We(V,{secretKey:Buffer.from(g.secretKey)});return(await he.post(`${t}/send`,{recipient:i,title:n,body:a,timestamp:p,payload:r,accessToken:l,protocolIdentifier:o,sender:{name:this.name,publicKey:M,signature:I}})).data}async onNewAccount(e,t){const i=e.publicKey||e.pubkey||e.pubKey,n=i?Ue(i):void 0;if(!n&&!e.address)throw new Error("PublicKey or Address must be defined");const a=e.address??await Be(n);if(!Fe(a))throw new Error(`Invalid address: "${a}"`);if(e.walletType==="abstracted_account"&&a.substring(0,3)!==ie)throw new Error(`Invalid abstracted account address "${a}", it should be a ${ie} address`);c.log("######## MESSAGE #######"),c.log("onNewAccount",e);const r=(await this.storage.get(h.LAST_SELECTED_WALLET))?.key,o={accountIdentifier:await j(a,e.network),senderId:e.senderId,origin:{type:t.origin,id:t.id},walletKey:r,address:a,publicKey:n,network:e.network,scopes:e.scopes,threshold:e.threshold,notification:e.notification,connectedAt:new Date().getTime(),walletType:e.walletType??"implicit",verificationType:e.verificationType,...e.verificationType==="proof_of_event"?{hasVerifiedChallenge:!1}:{}};return c.log("accountInfo","######## ACCOUNT INFO #######"),c.log("accountInfo",o),await this.accountManager.addAccount(o),await this.setActiveAccount(o),o}}let b;const ut=(u,s)=>(b&&s&&(b.disconnect(),b=void 0),b||(b||(b=new ue(u)),b));function A(u,s,e,t){function i(n){return n instanceof e?n:new e(function(a){a(n)})}return new(e||(e=Promise))(function(n,a){function r(p){try{l(t.next(p))}catch(g){a(g)}}function o(p){try{l(t.throw(p))}catch(g){a(g)}}function l(p){p.done?n(p.value):i(p.value).then(r,o)}l((t=t.apply(u,[])).next())})}class z extends pe{constructor(){super(),this.name="BeaconWalletNotInitialized",this.message='BeaconWallet needs to be initialized by calling `await BeaconWallet.requestPermissions({network: {type: "chosen_network"}})` first.'}}class wt extends pe{constructor(s){super(),this.requiredScopes=s,this.name="MissingRequiredScopes",this.message=`Required permissions scopes: ${s.join(",")} were not granted.`}}let ft=class{constructor(s){this.client=ut(s),this.client.subscribeToEvent(f.ACTIVE_ACCOUNT_SET,e=>A(this,void 0,void 0,function*(){this.account=e}))}validateRequiredScopesOrFail(s,e){const t=new Set(e);for(const i of s)t.has(i)&&t.delete(i);if(t.size>0)throw new wt(Array.from(t))}requestPermissions(s){return A(this,void 0,void 0,function*(){yield this.client.requestPermissions(s)})}getPKH(){return A(this,void 0,void 0,function*(){if(!this.account)throw new z;return this.account.address})}getPK(){var s;return A(this,void 0,void 0,function*(){if(!this.account)throw new z;return(s=this.account.publicKey)!==null&&s!==void 0?s:""})}mapTransferParamsToWalletParams(s){return A(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield U(this.formatParameters(e)))})}mapStakeParamsToWalletParams(s){return A(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield U(this.formatParameters(e)))})}mapUnstakeParamsToWalletParams(s){return A(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield U(this.formatParameters(e)))})}mapFinalizeUnstakeParamsToWalletParams(s){return A(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield U(this.formatParameters(e)))})}mapIncreasePaidStorageWalletParams(s){return A(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield Ke(this.formatParameters(e)))})}mapOriginateParamsToWalletParams(s){return A(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield $e(this.formatParameters(e)))})}mapDelegateParamsToWalletParams(s){return A(this,void 0,void 0,function*(){let e;yield this.client.showPrepare();try{e=yield s()}catch(t){throw yield this.client.hideUI(["alert"]),t}return this.removeDefaultParams(e,yield He(this.formatParameters(e)))})}formatParameters(s){return s.fee&&(s.fee=s.fee.toString()),s.storageLimit&&(s.storageLimit=s.storageLimit.toString()),s.gasLimit&&(s.gasLimit=s.gasLimit.toString()),s}removeDefaultParams(s,e){return s.fee||delete e.fee,s.storageLimit||delete e.storage_limit,s.gasLimit||delete e.gas_limit,e}sendOperations(s){return A(this,void 0,void 0,function*(){if(!this.account)throw new z;const e=this.account.scopes;this.validateRequiredScopesOrFail(e,[R.OPERATION_REQUEST]);const{transactionHash:t}=yield this.client.requestOperation({operationDetails:s});return t})}disconnect(){return A(this,void 0,void 0,function*(){yield this.client.destroy()})}clearActiveAccount(){return A(this,void 0,void 0,function*(){yield this.client.setActiveAccount()})}sign(s,e){return A(this,void 0,void 0,function*(){let t=ze(s);typeof e<"u"&&(t=Ge(e,t));const i=je(Xe(t)),n=this.getSigningType(e);if(n!==E.OPERATION)throw new Qe(`Taquito Beacon Wallet currently only supports signing operations, not ${n}`);const{signature:a}=yield this.client.requestSignPayload({payload:i,signingType:n});return a})}getSigningType(s){if(!s||s.length===0)return E.RAW;if(s.length===1){if(s[0]===5)return E.MICHELINE;if(s[0]===3)return E.OPERATION}throw new Error(`Invalid watermark ${JSON.stringify(s)}`)}};const gt=(u,s,e=!1)=>{const t=u,i={childList:!0},n=new MutationObserver(async a=>{for(const r of a)if(r.type==="childList")for(const o of r.addedNodes)await s(o)&&!e&&n.disconnect()});n.observe(t,i)},yt=(u,s)=>{const e=document.createElement("style");e.innerHTML=s,u.appendChild(e)},mt=async(u,s)=>{const e=await he({method:"get",url:"/assets/styles/beacon.css"}),t=new Promise((n,a)=>{gt(document.body,r=>{const o=r;if(typeof o.id=="string"&&o.id.startsWith("beacon-alert-wrapper")){const l=o?.shadowRoot;if(l){yt(l,e.data);const p=l.querySelector(".beacon-modal__close__wrapper");p&&p.addEventListener("click",()=>a("closed"))}return o.style.display="block",!0}return!1})}),i=u.client.requestPermissions(s);await Promise.race([t,i])};class Q extends ft{constructor(e){super(e);d(this,"subscribers",new Set)}async initialize(){return await this.client.subscribeToEvent(f.ACTIVE_ACCOUNT_SET,e=>{this.handleAccountSwitch(e)}),this}static async restore(e){const t=new Q(e),i=await t.client.getActiveAccount();if(!i){ae(t.disconnect());return}return t.account=i,await t.initialize()}static async create(e){const t=new Q(e);await t.client.getActiveAccount()&&ae(t.disconnect()),t.client=new ue(e),await t.initialize();const n=new Promise(async a=>{const r=t.subscribeToAccountSwitch(o=>{a(!0),r()})});return await Promise.all([mt(t),n]),t}async handleAccountSwitch(e){this.account=e,this.subscribers.forEach(t=>t(e))}subscribeToAccountSwitch(e){return this.subscribers.add(e),this.account&&e(this.account),()=>{this.subscribers.delete(e)}}async disconnect(){await super.disconnect(),await super.clearActiveAccount()}}export{Q as BeaconWallet};
